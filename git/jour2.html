<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Formation Git</title>

		<meta name="description" content="">
		<meta name="author" content="">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/solarized.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="../reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<link rel="stylesheet" href="css/styles.css">

		<!--[if lt IE 9]>
		<script src="../reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

        <footer id="slide-footer"> Formation Git<br /> Thibault Jouannic <span>2014</span> </footer>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                    <section>
                        <img src="img/gros_logo.png" style="border: 0 !important; box-shadow: none !important; background: inherit !important; "/>
                        <h1>Formation Git</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Nettoyer son historique</h1>
                        <h2>« Range ta chambre ! »</h2>
                    </section>

                    <section>
                        <h2>Avantages d'un historique bien propre</h2>
                        <ul>
                            <li>Lecture plus simple et rapide</li>
                            <li>Annulation de commits plus facile</li>
                            <li>Débuggage moins complexe</li>
                            <li>Partage de code et maintenance plus simple</li>
                            <li>Faciliter les fusions</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Rappel imporant</h2>
                        <blockquote>
                            « L'historique partagé jamais tu ne modifieras, sinon de toi et ton équipe
                              le malheur s'emparera » — Yoda.
                        </blockquote>
                    </section>

                    <section>
                        <h2>Commiter avec soin</h2>
                        <pre><code>
                            $ git commit -i
                            $ git add -p
                        </code></pre>
                    </section>

                    <section>
                        <h2>Réparer un commit</h2>
                        <pre><code>
                            $ git commit --amend  # Remplace le commit existant
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer les derniers commits</h2>
                        <pre><code>
                                              master &#x2190; HEAD
                                             /
                            A---B---C---D---E
                        </code></pre>
                        <pre><code>
                            $ git reset HEAD~3  # Reset le HEAD
                        </code></pre>
                        <pre><code>
                                  master &#x2190; HEAD
                                 /
                            A---B---C---D---E
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer un fichier</h2>
                        <pre><code>
    $ git rm --cached  # Supprime du HEAD
    $ git reset HEAD &lt;file&gt; # Supprime du staging
    $ # Pour les fichiers sensibles (à éviter si possible)
    $ git filter-branch --index-filter 'git rm --cached --ignore-unmatch &lt;file&gt;' \
        --prune-empty --tag-name-filter cat -- --all
    $ git push --all --force  # Vos collègues vous détesteront
                        </code></pre>
                    </section>

                    <section>
                        <h2>Récupérer un seul commit d'une autre branche</h2>
                        <pre><code>
                            $ git cherry-pick &lt;sha1&gt;
                        </code></pre>

                    </section>

                    <section>
                        <h2>L'artillerie lourde</h2>
                        <pre><code>
                    $ git rebase -i --onto &lt;destination&gt; &lt;upstream&gt; &lt;branch&gt;
                        </code></pre>
                        <p>Le rebase interactif permet de modifier, réordonner, découper, fusionner des commits.</p>
                        <pre><code>
                    $ git rebase -i HEAD~5  # Réécrire les 5 derniers commits
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Ajoutez plusieurs paragraphes dans un fichier</li>
                            <li>N'en commitez qu'un seul</li>
                            <li>Changez le commentaire du dernier commit</li>
                            <li>Supprimez les deux derniers commits de master</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Débugging avec git</h1>
                    </section>

                    <section>
                        <h2>Git blame</h2>
                        <p>Qui a fait ça ?!</p>
                        <pre><code>
                            $ git blame &lt;file&gt;
                            $ git blame &lt;file&gt; -L 50,55
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git bisect</h2>
                        <p>Recherche dichotomique de régression.</p>
                        <pre><code>
                            $ git bisect start
                            $ git bisect bad
                            $ git bisect good &lt;bon_commit&gt;
                            $ git bisect [bad|good|skip]  # Repeat
                            $ git bisect reset
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Git sur le serveur</h1>
                    </section>

                    <section>
                        <h2>Rappel : protocoles de partage</h2>
                        <ul>
                            <li>SSH : authentifié, lecture + écriture ;</li>
                            <li>Git : Lecture seulement, aucuns droits d'accès ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Créer un dépôt sur le serveur</h2>
                        <pre><code>
                            $ git init --bare repository_name.git
                            $ # ou
                            $ git clone --bare &lt;repository&gt; repository_name.git
                        </code></pre>
                        <p>Un <i>bare repository</i> est un dépôt uniquement dédié au partage :
                            il ne contient pas de WD.</p>
                        <p>Deux solutions : créer le dépôt sur le serveur, ou l'envoyer après coup (scp).</p>
                    </section>

                    <section>
                        <h2>Et c'est tout !</h2>
                        <p>Vos développeurs ont accès SSH sur un serveur quelconque ?</p>
                        <p>Placez-y un dépôt <i>bare</i>, et c'est tout bon.</p>
                    </section>

                    <section>
                        <h2>Configuration du serveur</h2>
                        <p>Première solution : créer un compte utilisateur pour chaque développeur sur le serveur.</p>
                        <p>Deuxième solution : créer un seul utilisateur <i>git</i>.</p>
                    </section>

                    <section>
                        <h2>Rappel : authentification par clés publiques</h2>
                        <pre><code>
                            $ ssh-keygen -t dsa
                            $ ssh-copy-id -i .ssh/id_dsa.pub git@git.serveur.com
                        </code></pre>
                        <p>Vous pouvez restreindre l'utilisateur aux commandes git en
                            lui assignant un shell spécial dans <i>/etc/passwd</i>.</p>
                        <pre><code>
                            git:x:1000:1000::/home/git:/usr/bin/git-shell
                        </code></pre>
                    </section>

                    <section>
                        <h2>Initialisation du dépôt</h2>
                        <pre><code>
        $ git clone ssh://git@git.serveur.com:/path/to/repository.git
        $ # ou
        $ git init
        $ Commit…
        $ git remote add origin ssh://git@git.serveur.com:/path/to/repository.git
        $ git push origin master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Autres solutions</h2>
                        <p>Gitosis : obsolète, dernier commit date de 4 ans ;</p>
                        <p>Gitolite : gère les permissions de manière fine ;</p>
                        <p>Git Daemon : pour un accès public read-only ;</p>
                        <p>Git Web : pour un accès http (mais pourquoi ?!) ;</p>
                    </section>

                    <section>
                        <h2>Github</h2>
                        <p>Faites plaisir à vos développeurs.
                            Github est devenu en quelques années un des principaux outils du monde du
                            développement.</p>
                        <p>Un peu comme un Facebook pour codeurs.</p>
                        <ul>
                            <li>Hébergement de dépôts gits</li>
                            <li>Dépôts publics / privés</li>
                            <li>Wiki</li>
                            <li>Bug tracker</li>
                            <li>Pull requests</li>
                            <li>Plans entrerpises</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Quelques commandes en détails</h1>
                    </section>

                    <section>
                        <h2>Git stash</h2>
                        <p>Je suis en plein milieu du dev, mais je dois faire un commit / merge / autre chose.</p>
                        <pre><code>
        $ git stash  # Met de côté les modifications en cours
        $ git stash save Message détaillé  # Idem, mais avec un message
        $ git stash list  # Liste les stashs disponibles
        $ git stash pop  # Applique les dernier stash
        $ git stash pop --index  # Idem, mais prend en compte le staging
        $ git stash branch  # Créé une branche depuis le commit initial
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git reset</h2>
                        <pre><code>
        Premier mode : reset sur un commit (HEAD si non spécifié)
        $ git reset --soft &lt;commit&gt;  # Déplace le HEAD *et* la branche sur &lt;commit&gt;
        $ git reset --mixed &lt;commit&gt;  # Idem, mais copie HEAD dans le staging
        $ git reset --hard &lt;commit&gt;   # Les deux premiers, mais copie HEAD dans le WD
                        </code></pre>
                        <pre><code>
        Deuxième mode : reset vers un chemin (idem, HEAD si commit non spécifié)
        $ git reset HEAD file.txt…
        Mêmes étapes que ci-dessus *mais* ne déplace pas le HEAD, et ne travaille que sur
        les fichiers / répertoires spécifiés.
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git checkout</h2>
                        <p>Contrairement à <i>git reset --hard</i>, <i>git checkout</i>
                           n'écrasera pas le WD en cas de risque de perte de données.</p>
                        <pre><code>
        $ git checkout &lt;commit&gt;
        # Déplace le HEAD (pas la branche) sur &lt;commit&gt;,
        et met à jour l'index et le WD *sauf* les fichiers modifiés (pfiou !)

        $ git checkout &lt;path&gt;
        # Met à jour le &lt;path&gt; du WD avec celui de l'index

        $ git checkout &lt;commit&gt; &lt;path&gt;
        # Met à jour le &lt;path&gt; du WD avec celui de &lt;commit&gt;
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Submodules et subtrees</h1>
                    </section>

                    <section>
                        <h2>Combiner des dépôts git</h2>
                        <p>Parfois, le besoin se fait sentir d'importer un dépôt git
                            dans un autre dépôt git.</p>
                        <p>Ex : bibliothèque.</p>
                        <p>Deux solutions : submodules et subtree.</p>
                    </section>

                    <section>
                        <h2>AVERTISSEMENT !</h2>
                        <p>Si vous pouvez l'éviter, faites-le !</p>
                        <p>Préférez utiliser les outils de votre langage pour lier
                            des projets ensembles.
                            Exemple : Virtualenv + pip + requirements.txt en Python.</p>
                        <p>Vous me remercierez plus tard.</p>
                    </section>

                    <section>
                        <h2>Les submodules</h2>
                        <p>Un submodule est un dépôt git dans un dépôt git.</p>
                        <p>Les dépôts sont liés mais restent indépendants.</p>
                        <pre><code>
            $ git submodule add https://github.com/twitter/bootstrap.git bootstrap
            $ git status
            $ cd bootstrap && git status
            $ cd ..
            $ cat .gitmodules
            $ git diff --cached bootstrap
                        </code></pre>
                    </section>

                    <section>
                        <h2>Modifier un submodule</h2>
                        <p>Une fois un sumbodule à jour (suite à un commit ou un merge),
                            il faut modifier la référence dans le projet principal,
                            et commiter.</p>
                    </section>

                    <section>
                        <h2>Attention aux pièges !</h2>
                        <pre><code>
            $ # Après avoir modifié un submodule, ne pas oublier de le pusher !
            $ git push --recurse-submodules=check
            $ # Après un git clone :
            $ git submodule init && git submodule update
            $ # Après un pull, si un submodule est modifié
            $ git submodule update
                        </code></pre>
                        <p>Et si le commit sur lequel pointe mon submodule n'est pas public ? Pas de bol !</p>
                        <p>Attention également aux changements de branche avec / sans submodules.</p>
                    </section>

                    <section>
                        <h2>Les subtrees</h2>
                        <p>Une solution alternative : dédier une branche distincte
                            pour le dépôt distant.</p>
                    </section>

                    <section>
                        <h2>Euh… Pardon ?</h2>
                        <pre><code>
            $ git remote add bootstrap_remote https://github.com/twitter/bootstrap.git
            $ git fetch bootstrap_remote
            $ git checkout -b bootstrap_branch bootstrap_remote/master
                        </code></pre>
                        <p>Vous voilà donc avec deux branches distinctes dont le contenu
                            est totalement différent.</p>
                        <p>Intégrons la nouvelle branche dans un sous répertoire de la première.</p>
                        <pre><code>
            $ git read-tree --prefix=bootstrap -u bootstrap_branch
                        </code></pre>
                    </section>

                    <section>
                        <h2>Euh… Pardon ?</h2>
                        <p>Récupérer le subtree distant :</p>
                        <pre><code>
                            $ git checkout bootstrap_branch
                            $ git pull
                            $ git checkout master
                            $ git merge --squash --no-commit -s subtree bootstrap_branch
                        </code></pre>
                        <p>Modifier le subtree local et pusher :</p>
                        <pre><code>
                            $ git checkout bootstrap_branch
                            $ git merge -s subtree master
                            $ git push
                        </code></pre>
                    </section>

                    <section>
                        <h2>Et mon diff ?</h2>
                        <pre><code>
                            $ git diff-tree -p bootstrap_branch
                            $ git diff-tree -p bootstrap_remote/master
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Intégrez votre librairie / framework préféré via un submodule</li>
                            <li>Idem via un subtree</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Les Hooks</h1>
                        <img src="http://www.linternaute.com/cinema/image_cache/objdbfilm/image/540/27222.jpg" />
                    </section>

                    <section>
                        <h2>Les hooks</h2>
                        <p>Un <i>hook</i> est un script prévu pour se déclencher à un moment précis.</p>
                        <pre><code>
                            $ ls .git/hooks
                        </code></pre>
                        <p>Les hooks peuvent être côté client ou côté serveur.</p>
                    </section>

                    <section>
                        <h2>Les hooks</h2>
                        <p>Exemples d'utilisation :</p>
                        <ul>
                            <li>vérifier que le message de commit respecte une certaine convention ;</li>
                            <li>vérifier les droits d'accès de certains fichiers ;</li>
                            <li>vérifer que les conventions de codage sont respectées ;</li>
                            <li>interdire de commiter des fichiers qui contiennent TODO, README, Fuck, etc. ;</li>
                            <li>lancer la mise en production après un push ;</li>
                            <li>interdire les commits après 17h ;</li>
                            <li>faire une bonne blague à un collègue ;</li>
                            <li>etc.</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Git et svn</h1>
                    </section>

                    <section>
                        <h2>Un comparatif Git / Svn</h2>
                        <p>Serait injuste pour SVN.</p>
                    </section>

                    <section>
                        <h2>Si vous aimez les antiquités…</h2>
                        <pre><code>
            $ aptitude install git-svn
            $ git-svn clone http://svn.example.com/svn/projet -T trunk projet
            $ cd projet
            $ git-svn show-ignore &gt;&gt; .git/info/exclude
            $ Commit… Commit… Commit…
            $ git svn rebase
            $ git svn dcommit
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Créez un dépôt git de votre projet courant à partir de son svn</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fonctionnement interne de Git</h1>
                    </section>

                    <section>
                        <h2>Dans le cœur de la bête</h2>
                        <p>Tout le dépôt git se trouve dans <i>.git</i>.</p>
                        <pre><code>
                            config -> Configuration du dépôt
                            HEAD -> Pointeur vers le commit en cours
                            index -> Staging area
                            objects -> Base de données des objets
                            refs -> Pointeurs vers des commits
                        </code></pre>
                        <p>Les objets sont indexés par contenu : clé = sha1 hash du contenu.</p>
                    </section>

                    <section>
                        <h2>Les objets</h2>
                        <p>Git gère quatre types d'objets :</p>
                        <ul>
                            <li>blob : contenu d'un fichier ;</li>
                            <li>tree : liste d'objet et leurs meta-données (noms, permissions) ;</li>
                            <li>commit : référence vers un tree, meta-datas, un ou plusieurs commits parents ;</li>
                            <li>tag : les tags ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Les références</h2>
                        <p>Une référence est simplement une étiquette qui pointe vers un commit / une arborescence ;</p>
                    </section>

                    <section>
                        <h2>Les packfiles</h2>
                        <p>À chaque commit, Git stocke l'intégralité du fichier commité.</p>
                        <p>Périodiquement, Git empaquette les fichiers presque identiques pour gagner en espace et efficacité.</p>
                    </section>
                </section>

                <section>
                    <h1>{Biblio|Réseau}graphie</h1>
                    <ul>
                        <li><a href="http://git-scm.com/book">http://git-scm.com/book</a></li>
                        <li><a href="http://www.github.com">http://www.github.com</a></li>
                        <li><a href="http://gitready.com/">http://gitready.com/</a></li>
                    </ul>
                </section>

			</div>

		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
		</script>
	</body>
</html>
