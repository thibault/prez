<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Formation Git</title>

		<meta name="description" content="">
		<meta name="author" content="">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/styles.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="../reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="../reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Formation Git</h1>
				</section>

				<section>
                    <h2>Thibault Jouannic</h2>
                    <p><a href="mailto:thibault@jouannic.fr">thibault@jouannic.fr</a> —
                    <a href="https://twitter.com/thibaultj">@thibaultj</a></p>
				</section>

                <section>
                    <h2>Première journée</h2>
                    <p>Plan</p>
                </section>

                <section>
                    <h2>Deuxième journée</h2>
                    <p>Plan</p>
                </section>

                <section>
                    <section>
                        <h1>La gestion de version</h1>
                    </section>

                    <section>
                        <h2>Pour travailler seul</h2>
                        <ul>
                            <li>Conserver un historique</li>
                            <li>Revenir en arrière</li>
                            <li>Ne pas perdre de données</li>
                            <li>Savoir où l'on en est</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Pour travailler à plusieurs</h2>
                        <li>Éviter les conflits</li>
                        <li>Savoir qui fait quoi</li>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Git – Histoire et philosophie</h1>
                    </section>

                    <section>
                        <h2>L'histoire de Git</h2>
                        <p>BitKeeper, SCM non libre, était utilisé par Linus Torvalds pour développer le noyau Linux.</p>
                        <p>Quand les développeurs décident d'en révoquer le droit d'utilisation, Linus décide
                           de construire son propre outil.</p>
                        <p>Git est donc développé pour des projets à trés grande ampleur.</p>
                    </section>

                    <section>
                        <h2>Caractéristiques et prérequis</h2>
                        <p>Git est donc développé par des développeurs hautement expérimentés,
                           et avec de trés fortes exigeances.</p>
                        <ul>
                            <li>Haute performance</li>
                            <li>Architecture distribuée</li>
                            <li>Protection contre les corruptions et pertes de données</li>
                            <li>Support d'un <i>workflow</i> non linéaire</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Mais pourquoi est-il si génial ?</h2>
                        <ul>
                            <li>Chaque version de fichier est sauvegardée (pas les deltas)</li>
                            <li>Rapide comme l'éclair</li>
                            <li>Fonctionne en local</li>
                            <li>Quasiment impossible de perdre des données</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <h2>Essayons !</h2>
                    <pre><code>
                        $ mkdir test && cd test
                        $ git init
                        $ touch file
                        $ git status
                        $ git add file
                        $ git status
                        $ git commit -a -m "First commit"
                        $ git status
                        $ git log
                    </code></pre>
                </section>

                <section>
                    <section>
                        <h1>Concepts et fonctionnement</h1>
                    </section>
                    <section>
                        <h2>Deux stuctures de données</h2>
                        <p>La base de données d'objets : toute modification s'apparente à un ajout à la base.
                            Chaque objet est indexé par son hash SHA1.</p>
                        <p>L'index mutable (<i>Stage</i> ou <i>Cache</i>) qui contient les infos sur
                            le répertoire de travail et le prochain commit.</p>
                    </section>
                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Dépôt</dt>
                            <dd>Ensemble des données et meta-données d'un projet géré sous git</dd>
                            <dt>Working directory (WD)</dt>
                            <dd>Ensemble local des fichiers et répertoires du projet</dd>
                            <dt>Commit</dt>
                            <dd>Enregistrement daté d'une modification du WD</dd>
                            <dt>Index / Staging area</dt>
                            <dd>Liste des modifications à commiter</dd>
                            <dt>Branche</dt>
                            <dd>Flux de commits parallèle.</dd>
                            <dt>Master</dt>
                            <dd>Branche principale du dépôt</dd>
                        </dl>
                    </section>
                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Tag</dt>
                            <dd>Étiquette désignant un commit précis</dd>
                            <dt>Fusion / Merge</dt>
                            <dd>Action de combiner les commits de plusieurs branches</dd>
                            <dt>Conflit</dt>
                            <dd>Incompatibilité empêchant une fusion automatique</dd>
                            <dt>HEAD</dt>
                            <dd>Désigne le dernier commit de la branche courante</dd>
                            <dt>ORIG_HEAD</dt>
                            <dd>La précédente position de HEAD</dd>
                        </dl>
                    </section>
                    <section>
                        <h2>Zones et états</h2>
                        <figure>
                            <img src="img/file_lifecycle.png" alt="" />
                            <figcaption><a href="http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository">Pro Git – Scott Chacon</a></figcaption>
                        </figure>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Avant de démarrer</h1>
                    </section>
                    <section>
                        <h2>La configuration</h2>
                        <ul>
                            <li>/etc/gitconfig</li>
                            <li>~/.gitconfig</li>
                            <li>.git/config</li>
                        </ul>
                        <pre><code>
$ git config --global user.name "Thibault Jouannic"
$ git config --global user.email "thibault@miximum.fr"
                        </code></pre>
                    </section>
                    <section>
                        <h2>La configuration</h2>
                        <pre><code>
[user]
    name = Thibault Jouannic
    email = thibault@miximum.fr
[color]
    ui = true
[alias]
    lg = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
    st = status
    ci = commit
[core]
    editor = vim
[merge]
    tool = vimdiff
                        </code></pre>
                    </section>
                    <section>
                        <h2>Le prompt</h2>
                        <p>TODO</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Opérations basiques</h1>
                    </section>
                    <section>
                        <h2>Premier dépôt</h2>
                        <p>Créer un nouveau dépôt</p>
                        <pre><code>$ git init</code></pre>
                        <p>Cloner un dépôt distant<p>
                        <pre><code>$ git clone https://github.com/thibault/prez.git</code></pre>
                    </section>

                    <section>
                        <h2>.gitignore</h2>
                        <p>Pour ignorer certains fichiers.</p>
                        <p><a href="https://gist.github.com/thibault/5804127">Exemple de .gitignore</a>
                    </section>

                    <section>
                        <h2>Préparer le commit</h2>
                        <pre><code>
$ # WD &#x2192; Staging
$ git add .  # Ajoute tous les fichiers sous le dir. courant
$ git add &lt;file&gt;  # Ajoute un seul fichier ou dir.
$ git add -u  # Ignore les fichiers non trackés, enregistre la suppr. de fichiers
$ git add -f  # Ajout de fichiers ignorés
$ git add -p / git add -i  # Interactif KILLER FEATURE!
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <pre><code>
$ # Staging &#x2192; Repository
$ git commit  # Commit et lance l'éditeur pour saisir le message
$ git commit -m "Mon message"
$ git commit -a  # Tout commiter, même ce qui n'est pas dans le staging
$ git commit -am "Mon message"  # Svn style
                        </code></pre>
                    </section>

                    <section>
                        <h2>Visualiser l'état du dépôt</h2>
                        <pre><code>
$ # HEAD &#x2260; Staging &#x2260; WD
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD file..." to unstage)
#
#	modified:   index.html
#
# Changes not staged for commit:
#   (use "git add file..." to update what will be committed)
#   (use "git checkout -- file..." to discard changes in working directory)
#
#	modified:   index.html
#
# Untracked files:
#   (use "git add file..." to include in what will be committed)
#
#	img
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer et déplacer des fichiers</h2>
                        <pre><code>
$ git rm  # Supprimer du repository et du WD
$ git rm --cached  # Supprimer du repository mais pas du WD
$ git mv source destination  # Déplace un fichier
                        </code></pre>
                    </section>

                    <section>
                        <h2>Sortir des fichiers du staging</h2>
                        <pre><code>
$ git reset HEAD file  # Égal la commande suivante :
$ git reset file  # Copie la dernière version commitée dans le staging
$ git reset -p  # La même, en interactif
$ # Ces trois dernières commandes ne touchent pas au WD
                        </code></pre>
                        <p><i>git reset</i> peut faire bien plus, comme nous
                            allons le voir plus tard.</p>
                    </section>

                    <section>
                        <h2>Annuler les modifications d'un fichier</h2>
                        <pre><code>
$ git checkout file  # Copie la version staging de file dans le WD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Annuler un commit</h2>
                        <p>Attention, il existe plusieurs méthodes. git revert créé un commit opposé à un commit existant.</p>
                        <pre><code>
$ git revert commit
$ git revert commit -n  # Annule un commit mais attends votre validation pour commiter
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <p>Créez et commitez plusieurs fichiers.</p>
                        <p>Modifiez plusieurs lignes d'un fichier, mais n'en
                           commitez qu'une partie.</p>
                        <p>Faites en sorte que <i>git status</i> affiche un même fichier
                            dans le staging ET le WD.</p>
                        <p>Amenez une modification dans le staging, puis annulez-la.</p>
                    </section>
                </section>


                <section>
                    <section>
                        <h1>Retrouver ce que l'on a fait</h1>
                    </section>
                    <section>
                        <h2>Voir les différences entre deux états</h2>
                        <pre><code>
$ git diff  # Montre les différences entre le WD et le staging
$ git diff &lt;file&gt;  # Limite à un seul fichier ou chemin
$ git diff --cached  # Différences entre staging et HEAD
$ git diff HEAD  # Différences entre le WD et HEAD
$ git diff &lt;commit&gt;  # Différences avec un commit / branch particulier
$ git diff &lt;commit&gt; &lt;commit&gt; # Différences entre deux commits
$ git diff --word-diff  # Différences mot à mot (au lieu de ligne à ligne)
$ git diff -w  # Ignore les espaces dans la comparaison
                        </code></pre>
                    </section>
                    <section>
                        <h2>Fouiller l'historique</h2>
                        <pre><code>
$ git log
$ git log &lt;branch&gt;
$ git log --author=Thibault
$ git log --grep=keyword -i -E
$ git log --graph
$ git log --format=oneline
$ git log --since="yesterday"
$ git log --since="1 hour ago"
$ git lg
                        </code></pre>
                    </section>
                    <section>
                        <h2>Voir des objets git</h2>
                        <pre><code>
$ git show  # Voir le dernier commit
$ git show &lt;commit&gt;
$ git show &lt;blob&gt;
$ git show &lt;tag&gt;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Spécifier un commit / révision</h2>
                        <pre><code>
$ git … HEAD^
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8^^
$ git … efc95493798d8~3
$ git … hotfixes@{yesterday}
$ git … HEAD@{5}
$ git … HEAD@{"1 hour ago"}
                        </code></pre>
                    </section>
                </section>
                <section>
                    <section>
                        <h1>Les branches</h1>
                        <p>Tatatiiiiinnn…</p>
                    </section>
                    <section>
                        <h2>Utilisez-les!</h2>
                        <p>Avec d'autres SCM, les branches sont lentes, complexes et pénibles à utiliser.</p>
                        <p>Pas avec Git ! Les branches sont un outil essentiel à maîtriser.</p>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <p>Uniquement une étiquette qui pointe sur un commit.</p>
                        <p>C'est tout ? C'est tout !</p>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_1.png" />
                        <pre><code>
                            $ git branch testing
                            $ git checkout testing
                        </code></pre>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_2.png" />
                        <pre><code>
                            Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_3.png" />
                        <pre><code>
                            $ git checkout master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_4.png" />
                        <pre><code>
                            $ Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>
                    <section>
                        <h2>Conséquences</h2>
                        <p>Créer / supprimer une branche est… rapide !</p>
                        <p>Il est possible de créer une branche n'importe quand… même depuis un ancien commit !</p>
                    </section>
                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Oups, j'ai oublié de faire une branche.</p>
                    </section>
                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git branch new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                         \
                                          new_feature
                        </code></pre>
                    </section>
                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git reset --soft HEAD~2
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  master &#x2190; HEAD
                        </code></pre>
                    </section>
                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ Commit… Commit… Commit…
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  E---F---G &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>
                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git checkout new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Quand utiliser une branche ?</h2>
                        <ul>
                            <li>Pour isoler un développement un peu long</li>
                            <li>Pour faire des tests sans casser tout le dépôt</li>
                            <li>Pour mettre quelques commits de côté</li>
                            <li>Juste parce qu'on peut !</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Créer une branche</h2>
                        <pre><code>
                            $ git branch &lt;name&gt; && git checkout &lt;name&gt;
                            $ # ou, plus rapide
                            $ git checkout -b &lt;name&gt;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Passer d'une branche à l'autre</h2>
                        <pre><code>
                            $ git checkout &lt;branch1&gt;
                            $ git checkout &lt;branch2&gt;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Supprimer une branche</h2>
                        <pre><code>
                            $ git branch -d &lt;name&gt;
                            $ git branch -D &lt;name&gt;  # si branche non fusionnée
                        </code></pre>
                    </section>
                    <section>
                        <h2>Lister les branches</h2>
                        <pre><code>
                            $ git branch  # Lister les branches locales
                            $ git branch -r  # Lister les branches distantes
                            $ git branch -a  # Combine les deux
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fusions de branches</h1>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <p>Now… what?</p>
                    </section>
                    <section>
                        <h2>Pas de panique !</h2>
                        <p>Si vous avez déjà tenté une fusion avec SVN ou autre, il est
                           probable que vous soyez terrifié.</p>
                        <p>Avec Git, ça va bien se passer :)</p>
                    </section>
                    <section>
                        <h2>Avant la fusion…</h2>
                        <p>Il est important d'avoir un dépôt propre.</p>
                        <p>Tous les fichiers sont commités, le WD et l'index sont propres.</p>
                        <p>Placer le HEAD sur la branche principale.</p>
                    </section>
                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            A---B &#x2190; master &#x2190; HEAD
                                 \
                                  C---D---E &#x2190; hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                                             \
                                              hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git branch -d hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>
                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Cas plus complexe</h2>
                        <p>Git rejoue les commits de <i>hotfix</i> sur master.</p>
                        <p>Le résultat est enregistré dans un commit qui a deux parents.</p>
                        <p>S'il n'y a pas de conflits, ce sera un commit vide.</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Aah! les conflits…</h2>
                        <p>Il arrive qu'un merge ne puisse être réalisé automatiquement.</p>
                        <p>Ex : Le même fichier modifé différemment dans deux branches distinctes.</p>
                    </section>
                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Imaginons un fichier A, et ses différentes versions à travers le temps.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                    </section>
                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Git considère trois versions du fichier : les deux dernières versions, et
                           le dernier ancêtre commun.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                        <p>Ici, A2, A4 et A6.</p>
                    </section>
                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p><i>git status</i> permet de voir les fichiers mergés avec succès, et les autres.</p>
                        <p><i>git log --merge -p</i> montre uniquement les commits qui impactent les fichiers à merger.</p>
                        <p><i>git show [:1,:2,:3]:&lt;file&gt;</i> montre les différentes versions du fichier.</p>
                        <p><i>git diff / git difftool</i> pour voir des différences.</p>
                    </section>
                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Git modifie les fichiers conflictuels pour inclure des marqueurs de diff.</p>
                        <pre><code>
                            Cette ligne est la même dans les deux branches                                  
                                                                                
                            <<<<<<< HEAD                                                                    
                            Ajouté dans la branche master                                                   
                            =======                                                                         
                            Ajouté dans la branche test                                                     
                            >>>>>>> test                                                                    
                                                                                                            
                            Cette partie du fichier est commune
                        </code></pre>
                    </section>
                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Modifier le fichier pour résoudre les conflits.</p>
                        <p><i>git add</i> puis <i>git commit</i></p>
                        <p><i>git mergetool</i> permet de lancer un outil de résolution de merge.</p>
                    </section>
                    <section>
                        <h2>Que faire après un merge ?</h2>
                        <pre><code>
                            $ git branch --merged  # montre toutes les branches mergées
                            $ git branch -d &lt;bug_42&gt;  # supprime la branche
                            $ git branch --no-merged  # montre les branches non fusionnées
                        </code></pre>
                        <p>Même une fois fusionnée, une branche peut continuer à vivre. Un autre
                            merge pourra être réalisé plus tard.</p>
                    </section>
                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <p>Tentons l'expérience suivante :</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git branch -D hotfix
                        </code></pre>
                    </section>
                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Les commits de ma branche <i>hotfix</i> sont-ils perdus ?</p>
                    </section>
                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G
                        </code></pre>
                        <p>En fait, les commits existent toujours, ils sont simplement inaccessibles.</p>
                        <p>Au bout de quelques jours, ils seront supprimés par le <i>Garbage collector</i> de git.</p>
                    </section>
                    <section>
                        <h2>Le reflog</h2>
                        <p>Git garde une trace de tous les changements de position de HEAD.</p>
                        <pre><code>
                            $ git reflog
                            $ git checkout G
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; HEAD
                        </code></pre>
                        <p>Mais… HEAD pointe directement vers un commit ? Pas une branche ?</p>
                    </section>
                    <section>
                        <h2>L'état <i>Detached HEAD</i></h2>
                        <p>Quand HEAD pointe directement vers un commit, on parle de detached HEAD.
                           Pour retrouver une situation stable, il suffit de créer une branche,
                           et de continuer comme si de rien n'était.</p>
                        <pre><code>
                            $ git commit -b newbranch
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; newbranch &#x2190; HEAD
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Rebasing</h1>
                    </section>
                    <section>
                        <h2>Qu'est-ce qu'un rebase ?</h2>
                        <p>Le rebase est une autre façon d'intégrer les modifications de
                            deux branches.</p>
                        <p><i>git rebase</i> réapplique les commits d'une branche sur
                            une autre base.</p>
                    </section>
                    <section>
                        <h2>Merge vs. Rebase</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        
                        <pre><code>
                            A---B---C---D---H &#x2190; master, hotfix
                                 \         /
                                  E---F---G
                        </code></pre>
                        <pre><code>
                            $ git rebase master
                        </code></pre>
                        
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; hotfix
                                         \
                                          master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Comment ça fonctionne ?</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <ol>
                            <li>git met de côté tous les commits de la branche <i>hotfix</i></li>
                            <li>la branche <i>hotfix</i> est déplacée sur le dernier commit de <i>master</i></li>
                            <li>les commits de côté sont tous ré-appliqués <em>un par un</em></li>
                        </ol>
                    </section>
                    <section>
                        <h2>Conséquences</h2>
                        <ul>
                            <li>Le résultat est le même que le merge, mais l'historique est « plat »</li>
                            <li>Il n'y a pas de commits de fusion vide</li>
                            <li>Chaque commit peut provoquer un conflit</li>
                            <li>Les commits sont réécrits, ce ne sont pas les mêmes (ids différents)</li>
                        </ul>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Quand privilégier rebase sur merge ?</h2>
                        <ul>
                            <li>Soigner son historique</li>
                            <li>Faciliter l'intégration de branches</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <p>Si l'on créé de petites branches en local, on se retrouve facilement
                            avec beaucoup de commits de fusion, et un historique difficile à lire.</p>
                        <pre><code>
                                      F---G &#x2190; bug2
                                     /
                            A---B---E---H---I &#x2190; master
                                 \
                                  C---D &#x2190; bug1
                        </code></pre>
                    </section>
                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <pre><code>
                            $ git rebase master bug1
                            $ git checkout master && merge bug1
                            $ git rebase master bug2
                            $ git checkout master && merge bug2
                        </code></pre>
                        <pre><code>
                                                                 bug2
                                                                /
                            A---B---E---H---I---C'---D'---F'---G' &#x2190; master
                                                      \
                                                       bug1
                        </code></pre>
                    </section>
                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <p>Je n'ai pas créé ma branche depuis le bon commit.</p>
                        <pre><code>
                            A---B---H---I---J &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                                       \
                                        E---F &#x2190; bug_urgent
                        </code></pre>
                        <p>Et si je veux passer <i>bug_urgent</i> en production, mais
                            pas <i>bug_en_cours</i> ?</p>
                    </section>
                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <pre><code>
                            $ git rebase --onto production bug_en_cours bug_urgent
                        </code></pre>
                        <pre><code>
                            A---B---H---I---J---E'---F' &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                        </code></pre>
                        <p>Les commits sont tous ceux qui sont dans <i>bug_urgent</i>
                            mais pas dans <i>bug_en_cours</i>.</p>
                    </section>
                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            A---B &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_1
                                       \
                                        E---F &#x2190; bug_2
                        </code></pre>
                        <p>Oups ! bug_1 et bug_2 n'ont rien à voir.</p>
                    </section>
                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            $ git rebase --onto production  bug_1 bug_2
                        </code></pre>
                        <pre><code>
                            A---B &#x2190; production
                                |\
                                | C---D---G &#x2190; bug_1
                                 \
                                   E'---F' &#x2190; bug_2

                        </code></pre>
                    </section>
                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <p>Si je veux supprimer les commits C et D ?</p>
                    </section>
                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <pre><code>
                            $ git rebase --onto B D master
                            $ # Remplacer B et D par les sha1 des commits
                        </code></pre>
                        <pre><code>
                            A---B---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                 \
                                  E---F---G &#x2190; master local
                        </code></pre>
                    </section>
                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            $ git pull --rebase
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                         \
                                          E'---F'---G' &#x2190; master local
                        </code></pre>
                        <pre><code>
                            $ git push
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master distant
                                                       \
                                                        master local
                        </code></pre>
                    </section>
                    <section>
                        <h2>Grands pouvoirs, grandes responsabilités</h2>
                        <p>si vous réécrivez l'historique d'une branche partagée,
                            vos collègues vous tremperont dans le goudron et les plumes.</p>
                        <p><i>git rebase</i> ne doit donc être utilisé que pour
                            les branches locales.</p>
                    </section>
                    <section>
                        <h2>Et si un rebase ne se passe pas bien ?</h2>
                        <p>Les commits sont réappliqués un par un. Il y a donc des
                            conflits potentiels.</p>
                        <pre><code>
                            $ git status  # Comprendre ce qui se passe
                            $ # régler le conflit, puis :
                            $ git rebase --continue  # reprendre le travail, ou
                            $ git rebase --abort  # Tout annuler, ou
                            $ git rebase --skip  # Continuer en laissant de côté ce commit
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Dépôts distants</h1>
                        <p>Parce qu'il faut bien partager le code à un moment ou à un autre.</p>
                    </section>
                    <section>
                        <h2>Git est décentralisé</h2>
                        <p>Rappel : git est un système décentralisé. Il n'y a pas
                            de notion de dépôt central.</p>
                        <p>Sauf par convention.</p>
                        <p>Il est donc possible de créer autant de dépôts distants
                            que nécessaire.</p>
                    </section>
                    <section>
                        <h2>Git remote</h2>
                        <p>Si vous clonez un dépôt, git l'enregistre comme dépôt distant
                            dans le nouveau dépôt local.
                        </p>
                        <pre><code>
                            $ git clone …
                            $ git remote  # Lister les dépôts distants
                            $ git remote show origin  # Détail sur le dépôt distant
                        </code></pre>
                       <p>Par convention, le dépôt distant par défaut se nomme <i>origin</i>.</p>
                    </section>
                    <section>
                        <h2>Git remote</h2>
                        <p><i>git remote</i> sert à gérer les dépôts distants.</p>
                        <pre><code>
                            $ git remote add &lt;name&gt; &lt;url&gt;  # Ajoute un nouveau remote
                            $ git remote rm …
                            $ git remote mv …
                            $ git help remote
                        </code></pre>
                    </section>
                    <section>
                        <h2>Protocoles de communication</h2>
                        <p>Un dépôt git peut être partagé via de nombreux protocoles. Parmi les plus courants :</p>
                        <ul>
                            <li>SSH : ssh://[user@]host.xz[:port]/path/to/repo.git/</li>
                            <li>GIT : git://host.xz[:port]/path/to/repo.git/</li>
                            <li>Filesystem : file:///path/to/repo.git</li>
                        </ul>
                        <p>Ssh:// est le plus sécurisé et recommandé. Git:// est en read-only.
                           Le filesystem n'est à utiliser que pour les tests durant cette
                           formation.</p>
                    </section>
                    <section>
                        <h2>Branches distantes</h2>
                        <p>Une branche distante est une branche locale <i>read-only</i>
                            qui représente une branche sur le dépôt distant. Euh… wat ?
                        </p>
                        <pre><code>
                            $ git branch -a
                            * master
                            remotes/origin/master
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                         \
                                          master
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                     \
                                      master
                        </code></pre>
                        <pre><code>
                            A---B---C &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                        <pre><code>
                            A---B---C---E &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git fetch  # Télécharge les données du serveur
                            $ git merge / git rebase  # ou, plus court :
                            $ git pull / git pull --rebase
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D---G &#x2190; origin/master
                                             \
                                              E---F &#x2190; master
                        </code></pre>
                    </section>
                    <section>
                        <h2>Branches trackées ou non</h2>
                        <p>Toutes les branches du serveur local n'ont pas à être sur le serveur, et
                            vice-versa.</p>
                        <p>Une <i>branche trackée</i> est une branche locale qui a
                            une relation directe avec une branche distante.</p>
                        <pre><code>
            $ git fetch  # Ne télécharge que les branches trackées de origin
            $ git fetch origin &lt;branch&gt;  # Pour les autres branches
            $ git pull  # Fetch + pull pour les branches correspondantes
            $ git push  # Envoie les données vers la branches distante correspondante
            $ git checkout -b origin/&lt;branch&gt;  # Récupère et tracke une branche distante
                        </code></pre>
                    </section>
                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p><i>git push</i> envoie les données locales sur le serveur distant.</p>
                        <pre><code>
                            $ git push  # Seulement les branches trackées
                            $ git push -u origin &lt;branch&gt; # Push une nouvelle branche
                            $ git push origin :&lt;branch&gt;  # Supprime une branche distante
                        </code></pre>
                    </section>
                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p>Évidemment, il faut avoir un droit le lecture / écriture sur le dépôt distant.</p>
                        <p>Il faut également que le dépôt local soit à jour.</p>
                    </section>
                </section>
			</div>

		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: '../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: '../reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
