<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Formation Git</title>

		<meta name="description" content="">
		<meta name="author" content="">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/styles.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="../reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="../reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                    <section>
                        <h1>Formation Git</h1>
                    </section>

                    <section>
                        <h2>Thibault Jouannic</h2>
                        <p><a href="mailto:thibault@jouannic.fr">thibault@jouannic.fr</a> —
                        <a href="https://twitter.com/thibaultj">@thibaultj</a></p>
                    </section>
				</section>

                <section>
                    <section>
                        <h1>Git — Introduction</h1>
                    </section>

                    <section>
                        <h2>Pour travailler seul</h2>
                        <ul>
                            <li>Conserver un historique</li>
                            <li>Revenir en arrière</li>
                            <li>Ne pas perdre de données</li>
                            <li>Savoir où l'on en est</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Pour travailler à plusieurs</h2>
                        <li>Partager le travail</li>
                        <li>Éviter les conflits</li>
                        <li>Savoir qui fait quoi</li>
                    </section>

                    <section>
                        <h2>L'histoire de Git</h2>
                        <p>BitKeeper, SCM non libre, était utilisé par Linus Torvalds pour développer le noyau Linux.</p>
                        <p>Quand les développeurs décident d'en révoquer le droit d'utilisation, Linus décide
                           de construire son propre outil.</p>
                        <p>Git est donc développé pour des projets à trés grande ampleur.</p>
                    </section>

                    <section>
                        <h2>Caractéristiques et prérequis</h2>
                        <p>Git est donc développé par des développeurs hautement expérimentés,
                           et avec de trés fortes exigeances.</p>
                        <ul>
                            <li>Haute performance</li>
                            <li>Architecture distribuée</li>
                            <li>Protection contre les corruptions et pertes de données</li>
                            <li>Support d'un <i>workflow</i> non linéaire</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Mais pourquoi est-il si génial ?</h2>
                        <ul>
                            <li>Chaque version de fichier est sauvegardée (pas les deltas)</li>
                            <li>Rapide comme l'éclair</li>
                            <li>Fonctionne en local</li>
                            <li>Quasiment impossible de perdre des données</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Essayons !</h2>
                        <pre><code>
                            $ mkdir test && cd test
                            $ git init
                            $ touch file
                            $ git status
                            $ git add file
                            $ git status
                            $ git commit -a -m "First commit"
                            $ git status
                            $ git log
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Concepts et fonctionnement</h1>
                    </section>

                    <section>
                        <h2>Deux stuctures de données</h2>
                        <p>La base de données d'objets : toute modification s'apparente à un ajout à la base.
                            Chaque objet est indexé par son hash SHA1.</p>
                        <p>L'index mutable (<i>Stage</i> ou <i>Cache</i>) qui contient les infos sur
                            le répertoire de travail et le prochain commit.</p>
                    </section>

                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Dépôt</dt>
                            <dd>Ensemble des données et meta-données d'un projet géré sous git</dd>
                            <dt>Working directory (WD)</dt>
                            <dd>Ensemble local des fichiers et répertoires du projet</dd>
                            <dt>Commit</dt>
                            <dd>Enregistrement daté d'une modification du WD</dd>
                            <dt>Index / Staging area</dt>
                            <dd>Liste des modifications à commiter</dd>
                            <dt>Branche</dt>
                            <dd>Flux de commits parallèle.</dd>
                            <dt>Master</dt>
                            <dd>Branche principale du dépôt</dd>
                        </dl>
                    </section>

                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Tag</dt>
                            <dd>Étiquette désignant un commit précis</dd>
                            <dt>Fusion / Merge</dt>
                            <dd>Action de combiner les commits de plusieurs branches</dd>
                            <dt>Conflit</dt>
                            <dd>Incompatibilité empêchant une fusion automatique</dd>
                            <dt>HEAD</dt>
                            <dd>Désigne le dernier commit de la branche courante</dd>
                            <dt>ORIG_HEAD</dt>
                            <dd>La précédente position de HEAD</dd>
                        </dl>
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <figure>
                            <img src="img/zones.png" alt="" />
                            <figcaption><a href="http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository">Pro Git – Scott Chacon</a></figcaption>
                        </figure>
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <figure>
                            <img src="img/file_lifecycle.png" alt="" />
                            <figcaption><a href="http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository">Pro Git – Scott Chacon</a></figcaption>
                        </figure>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Avant de démarrer</h1>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <ul>
                            <li>/etc/gitconfig</li>
                            <li>~/.gitconfig</li>
                            <li>.git/config</li>
                        </ul>
                        <pre><code>
$ git config --global user.name "Thibault Jouannic"
$ git config --global user.email "thibault@miximum.fr"
                        </code></pre>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <pre><code>
[user]
    name = Thibault Jouannic
    email = thibault@miximum.fr
[color]
    ui = true
[alias]
    lg = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
    st = status
    ci = commit
[core]
    editor = vim
[merge]
    tool = vimdiff
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Opérations basiques</h1>
                    </section>

                    <section>
                        <h2>Premier dépôt</h2>
                        <p>Créer un nouveau dépôt</p>
                        <pre><code>$ git init</code></pre>
                        <p>Cloner un dépôt distant<p>
                        <pre><code>$ git clone https://github.com/thibault/prez.git</code></pre>
                    </section>

                    <section>
                        <h2>.gitignore</h2>
                        <p>Pour ignorer certains fichiers.</p>
                        <p><a href="https://gist.github.com/thibault/5804127">Exemple de .gitignore</a>
                        <pre><code>
*.pyc
cache/
.DS_Store?
ehthumbs.db
Icon?
Thumbs.db
*.swp
.*.swp
*~
*.lock
*.out
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer le commit</h2>
                        <pre><code>
$ # WD &#x2192; Staging
$ git add .  # Ajoute tous les fichiers sous le dir. courant
$ git add &lt;file&gt;  # Ajoute un seul fichier ou dir.
$ git add -u  # Ignore les fichiers non trackés, enregistre la suppr. de fichiers
$ git add -f  # Ajout de fichiers ignorés
$ git add -p / git add -i  # Interactif KILLER FEATURE!
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <pre><code>
$ # Staging &#x2192; Repository
$ git commit  # Commit et lance l'éditeur pour saisir le message
$ git commit -m "Mon message"
$ git commit -a  # Tout commiter, même ce qui n'est pas dans le staging
$ git commit -am "Mon message"  # Svn style
                        </code></pre>
                    </section>

                    <section>
                        <h2>Visualiser l'état du dépôt</h2>
                        <pre><code>
$ # HEAD &#x2260; Staging &#x2260; WD
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD file..." to unstage)
#
#	modified:   index.html
#
# Changes not staged for commit:
#   (use "git add file..." to update what will be committed)
#   (use "git checkout -- file..." to discard changes in working directory)
#
#	modified:   index.html
#
# Untracked files:
#   (use "git add file..." to include in what will be committed)
#
#	img
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer et déplacer des fichiers</h2>
                        <pre><code>
$ git rm  # Supprimer du repository et du WD
$ git rm --cached  # Supprimer du repository mais pas du WD
$ git mv source destination  # Déplace un fichier
                        </code></pre>
                    </section>

                    <section>
                        <h2>Sortir des fichiers du staging</h2>
                        <pre><code>
$ git reset HEAD file  # Égal la commande suivante :
$ git reset file  # Copie la dernière version commitée dans le staging
$ git reset -p  # La même, en interactif
$ # Ces trois dernières commandes ne touchent pas au WD
                        </code></pre>
                        <p><i>git reset</i> peut faire bien plus, comme nous
                            allons le voir plus tard.</p>
                    </section>

                    <section>
                        <h2>Annuler les modifications d'un fichier</h2>
                        <pre><code>
$ git checkout file  # Copie la version staging de file dans le WD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Annuler un commit</h2>
                        <p>Attention, il existe plusieurs méthodes. git revert créé un commit opposé à un commit existant.</p>
                        <pre><code>
$ git revert commit
$ git revert commit -n  # Annule un commit mais attends votre validation pour commiter
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Retrouver l'info</h1>
                    </section>

                    <section>
                        <h2>Voir les différences entre deux états</h2>
                        <pre><code>
$ git diff  # Montre les différences entre le WD et le staging
$ git diff &lt;file&gt;  # Limite à un seul fichier ou chemin
$ git diff --cached  # Différences entre staging et HEAD
$ git diff HEAD  # Différences entre le WD et HEAD
$ git diff &lt;commit&gt;  # Différences avec un commit / branch particulier
$ git diff &lt;commit&gt; &lt;commit&gt; # Différences entre deux commits
$ git diff --word-diff  # Différences mot à mot (au lieu de ligne à ligne)
$ git diff -w  # Ignore les espaces dans la comparaison
                        </code></pre>
                    </section>

                    <section>
                        <h2>Fouiller l'historique</h2>
                        <pre><code>
$ git log
$ git log &lt;branch&gt;
$ git log --author=Thibault
$ git log --grep=keyword -i -E
$ git log --graph
$ git log --format=oneline
$ git log --since="yesterday"
$ git log --since="1 hour ago"
$ git lg
                        </code></pre>
                    </section>

                    <section>
                        <h2>Voir des objets git</h2>
                        <pre><code>
$ git show  # Voir le dernier commit
$ git show &lt;commit&gt;
$ git show &lt;blob&gt;
$ git show &lt;tag&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un commit / révision</h2>
                        <pre><code>
$ git … HEAD^
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8^^
$ git … efc95493798d8~3
$ git … hotfixes@{yesterday}
$ git … HEAD@{5}
$ git … HEAD@{"1 hour ago"}
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un intervalle de commits</h2>
                        <pre><code>
$ git log efc95493798d8..
$ git log efc95493798d8..efc95493798d8~5
$ git log HEAD~5..
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Les branches</h1>
                        <p>Tatatiiiiinnn…</p>
                    </section>

                    <section>
                        <h2>Utilisez-les!</h2>
                        <p>Avec d'autres SCM, les branches sont lentes, complexes et pénibles à utiliser.</p>
                        <p>Pas avec Git ! Les branches sont un outil essentiel à maîtriser.</p>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <p>Uniquement une étiquette qui pointe sur un commit.</p>
                        <p>C'est tout ? C'est tout !</p>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_1.png" />
                        <pre><code>
                            $ git branch testing
                            $ git checkout testing
                        </code></pre>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_2.png" />
                        <pre><code>
                            Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_3.png" />
                        <pre><code>
                            $ git checkout master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <img src="img/git_branch_4.png" />
                        <pre><code>
                            $ Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <p>Créer / supprimer une branche est… rapide !</p>
                        <p>Il est possible de créer une branche n'importe quand… même depuis un ancien commit !</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Oups, j'ai oublié de faire une branche.</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git branch new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                         \
                                          new_feature
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git reset --soft HEAD~2
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ Commit… Commit… Commit…
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  E---F---G &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git checkout new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand utiliser une branche ?</h2>
                        <ul>
                            <li>Pour isoler un développement un peu long</li>
                            <li>Pour faire des tests sans casser tout le dépôt</li>
                            <li>Pour mettre quelques commits de côté</li>
                            <li>Juste parce qu'on peut !</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Créer une branche</h2>
                        <pre><code>
                            $ git branch &lt;name&gt; && git checkout &lt;name&gt;
                            $ # ou, plus rapide
                            $ git checkout -b &lt;name&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Passer d'une branche à l'autre</h2>
                        <pre><code>
                            $ git checkout &lt;branch1&gt;
                            $ git checkout &lt;branch2&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer une branche</h2>
                        <pre><code>
                            $ git branch -d &lt;name&gt;
                            $ git branch -D &lt;name&gt;  # si branche non fusionnée
                        </code></pre>
                    </section>

                    <section>
                        <h2>Lister les branches</h2>
                        <pre><code>
                            $ git branch  # Lister les branches locales
                            $ git branch -r  # Lister les branches distantes
                            $ git branch -a  # Combine les deux
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fusions de branches</h1>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <p>Now… what?</p>
                    </section>

                    <section>
                        <h2>Pas de panique !</h2>
                        <p>Si vous avez déjà tenté une fusion avec SVN ou autre, il est
                           probable que vous soyez terrifié.</p>
                        <p>Avec Git, ça va bien se passer :)</p>
                    </section>

                    <section>
                        <h2>Avant la fusion…</h2>
                        <p>Il est important d'avoir un dépôt propre.</p>
                        <p>Tous les fichiers sont commités, le WD et l'index sont propres.</p>
                        <p>Placer le HEAD sur la branche principale.</p>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            A---B &#x2190; master &#x2190; HEAD
                                 \
                                  C---D---E &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                                             \
                                              hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git branch -d hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <p>Git rejoue les commits de <i>hotfix</i> sur master.</p>
                        <p>Le résultat est enregistré dans un commit qui a deux parents.</p>
                        <p>S'il n'y a pas de conflits, ce sera un commit vide.</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aah! les conflits…</h2>
                        <p>Il arrive qu'un merge ne puisse être réalisé automatiquement.</p>
                        <p>Ex : Le même fichier modifé différemment dans deux branches distinctes.</p>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Imaginons un fichier A, et ses différentes versions à travers le temps.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Git considère trois versions du fichier : les deux dernières versions, et
                           le dernier ancêtre commun.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                        <p>Ici, A2, A4 et A6.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p><i>git status</i> permet de voir les fichiers mergés avec succès, et les autres.</p>
                        <p><i>git log --merge -p</i> montre uniquement les commits qui impactent les fichiers à merger.</p>
                        <p><i>git show [:1,:2,:3]:&lt;file&gt;</i> montre les différentes versions du fichier.</p>
                        <p><i>git diff / git difftool</i> pour voir des différences.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Git modifie les fichiers conflictuels pour inclure des marqueurs de diff.</p>
                        <pre><code>
                            Cette ligne est la même dans les deux branches

                            <<<<<<< HEAD
                            Ajouté dans la branche master
                            =======
                            Ajouté dans la branche test
                            >>>>>>> test

                            Cette partie du fichier est commune
                        </code></pre>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Modifier le fichier pour résoudre les conflits.</p>
                        <p><i>git add</i> puis <i>git commit</i></p>
                        <p><i>git mergetool</i> permet de lancer un outil de résolution de merge.</p>
                    </section>

                    <section>
                        <h2>Que faire après un merge ?</h2>
                        <pre><code>
                            $ git branch --merged  # montre toutes les branches mergées
                            $ git branch -d &lt;bug_42&gt;  # supprime la branche
                            $ git branch --no-merged  # montre les branches non fusionnées
                        </code></pre>
                        <p>Même une fois fusionnée, une branche peut continuer à vivre. Un autre
                            merge pourra être réalisé plus tard.</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <p>Tentons l'expérience suivante :</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git branch -D hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Les commits de ma branche <i>hotfix</i> sont-ils perdus ?</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G
                        </code></pre>
                        <p>En fait, les commits existent toujours, ils sont simplement inaccessibles.</p>
                        <p>Au bout de quelques jours, ils seront supprimés par le <i>Garbage collector</i> de git.</p>
                    </section>

                    <section>
                        <h2>Le reflog</h2>
                        <p>Git garde une trace de tous les changements de position de HEAD.</p>
                        <pre><code>
                            $ git reflog
                            $ git checkout G
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; HEAD
                        </code></pre>
                        <p>Mais… HEAD pointe directement vers un commit ? Pas une branche ?</p>
                    </section>

                    <section>
                        <h2>L'état <i>Detached HEAD</i></h2>
                        <p>Quand HEAD pointe directement vers un commit, on parle de detached HEAD.
                           Pour retrouver une situation stable, il suffit de créer une branche,
                           et de continuer comme si de rien n'était.</p>
                        <pre><code>
                            $ git commit -b newbranch
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; newbranch &#x2190; HEAD
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Rebasing</h1>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'un rebase ?</h2>
                        <p>Le rebase est une autre façon d'intégrer les modifications de
                            deux branches.</p>
                        <p><i>git rebase</i> réapplique les commits d'une branche sur
                            une autre base.</p>
                    </section>

                    <section>
                        <h2>Merge vs. Rebase</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>

                        <pre><code>
                            A---B---C---D---H &#x2190; master, hotfix
                                 \         /
                                  E---F---G
                        </code></pre>
                        <pre><code>
                            $ git rebase master
                        </code></pre>

                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; hotfix
                                         \
                                          master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment ça fonctionne ?</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <ol>
                            <li>git met de côté tous les commits de la branche <i>hotfix</i></li>
                            <li>la branche <i>hotfix</i> est déplacée sur le dernier commit de <i>master</i></li>
                            <li>les commits de côté sont tous ré-appliqués <em>un par un</em></li>
                        </ol>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <ul>
                            <li>Le résultat est le même que le merge, mais l'historique est « plat »</li>
                            <li>Il n'y a pas de commits de fusion vide</li>
                            <li>Chaque commit peut provoquer un conflit</li>
                            <li>Les commits sont réécrits, ce ne sont pas les mêmes (ids différents)</li>
                        </ul>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand privilégier rebase sur merge ?</h2>
                        <ul>
                            <li>Soigner son historique</li>
                            <li>Faciliter l'intégration de branches</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <p>Si l'on créé de petites branches en local, on se retrouve facilement
                            avec beaucoup de commits de fusion, et un historique difficile à lire.</p>
                        <pre><code>
                                      F---G &#x2190; bug2
                                     /
                            A---B---E---H---I &#x2190; master
                                 \
                                  C---D &#x2190; bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <pre><code>
                            $ git rebase master bug1
                            $ git checkout master && merge bug1
                            $ git rebase master bug2
                            $ git checkout master && merge bug2
                        </code></pre>
                        <pre><code>
                                                                 bug2
                                                                /
                            A---B---E---H---I---C'---D'---F'---G' &#x2190; master
                                                      \
                                                       bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <p>Je n'ai pas créé ma branche depuis le bon commit.</p>
                        <pre><code>
                            A---B---H---I---J &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                                       \
                                        E---F &#x2190; bug_urgent
                        </code></pre>
                        <p>Et si je veux passer <i>bug_urgent</i> en production, mais
                            pas <i>bug_en_cours</i> ?</p>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <pre><code>
                            $ git rebase --onto production bug_en_cours bug_urgent
                        </code></pre>
                        <pre><code>
                            A---B---H---I---J---E'---F' &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                        </code></pre>
                        <p>Les commits sont tous ceux qui sont dans <i>bug_urgent</i>
                            mais pas dans <i>bug_en_cours</i>.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            A---B &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_1
                                       \
                                        E---F &#x2190; bug_2
                        </code></pre>
                        <p>Oups ! bug_1 et bug_2 n'ont rien à voir.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            $ git rebase --onto production  bug_1 bug_2
                        </code></pre>
                        <pre><code>
                            A---B &#x2190; production
                                |\
                                | C---D---G &#x2190; bug_1
                                 \
                                   E'---F' &#x2190; bug_2

                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <p>Si je veux supprimer les commits C et D ?</p>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <pre><code>
                            $ git rebase --onto B D master
                            $ # Remplacer B et D par les sha1 des commits
                        </code></pre>
                        <pre><code>
                            A---B---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                 \
                                  E---F---G &#x2190; master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            $ git pull --rebase
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                         \
                                          E'---F'---G' &#x2190; master local
                        </code></pre>
                        <pre><code>
                            $ git push
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master distant
                                                       \
                                                        master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Grands pouvoirs, grandes responsabilités</h2>
                        <p>si vous réécrivez l'historique d'une branche partagée,
                            vos collègues vous tremperont dans le goudron et les plumes.</p>
                        <p><i>git rebase</i> ne doit donc être utilisé que pour
                            les branches locales.</p>
                    </section>

                    <section>
                        <h2>Et si un rebase ne se passe pas bien ?</h2>
                        <p>Les commits sont réappliqués un par un. Il y a donc des
                            conflits potentiels.</p>
                        <pre><code>
                            $ git status  # Comprendre ce qui se passe
                            $ # régler le conflit, puis :
                            $ git rebase --continue  # reprendre le travail, ou
                            $ git rebase --abort  # Tout annuler, ou
                            $ git rebase --skip  # Continuer en laissant de côté ce commit
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Dépôts distants</h1>
                        <p>Parce qu'il faut bien partager le code à un moment ou à un autre.</p>
                    </section>

                    <section>
                        <h2>Git est décentralisé</h2>
                        <p>Rappel : git est un système décentralisé. Il n'y a pas
                            de notion de dépôt central.</p>
                        <p>Sauf par convention.</p>
                        <p>Il est donc possible de créer autant de dépôts distants
                            que nécessaire.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p>Si vous clonez un dépôt, git l'enregistre comme dépôt distant
                            dans le nouveau dépôt local.
                        </p>
                        <pre><code>
                            $ git clone …
                            $ git remote  # Lister les dépôts distants
                            $ git remote show origin  # Détail sur le dépôt distant
                        </code></pre>
                       <p>Par convention, le dépôt distant par défaut se nomme <i>origin</i>.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p><i>git remote</i> sert à gérer les dépôts distants.</p>
                        <pre><code>
                            $ git remote add &lt;name&gt; &lt;url&gt;  # Ajoute un nouveau remote
                            $ git remote rm …
                            $ git remote mv …
                            $ git help remote
                        </code></pre>
                    </section>

                    <section>
                        <h2>Protocoles de communication</h2>
                        <p>Un dépôt git peut être partagé via de nombreux protocoles. Parmi les plus courants :</p>
                        <ul>
                            <li>SSH : ssh://[user@]host.xz[:port]/path/to/repo.git/</li>
                            <li>GIT : git://host.xz[:port]/path/to/repo.git/</li>
                            <li>Filesystem : file:///path/to/repo.git</li>
                        </ul>
                        <p>Ssh:// est le plus sécurisé et recommandé. Git:// est en read-only.
                           Le filesystem n'est à utiliser que pour les tests durant cette
                           formation.</p>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <p>Une branche distante est une branche locale <i>read-only</i>
                            qui représente une branche sur le dépôt distant. Euh… wat ?
                        </p>
                        <pre><code>
                            $ git branch -a
                            * master
                            remotes/origin/master
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                         \
                                          master
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                     \
                                      master
                        </code></pre>
                        <pre><code>
                            A---B---C &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                        <pre><code>
                            A---B---C---E &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git fetch  # Télécharge les données du serveur
                            $ git merge / git rebase  # ou, plus court :
                            $ git pull / git pull --rebase
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D---G &#x2190; origin/master
                                             \
                                              E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches trackées ou non</h2>
                        <p>Toutes les branches locales n'ont pas à être sur le serveur, et
                            vice-versa.</p>
                        <p>Une <i>branche trackée</i> est une branche locale qui a
                            une relation directe avec une branche distante.</p>
                        <pre><code>
            $ git fetch  # Ne télécharge que les branches trackées de origin
            $ git fetch origin &lt;branch&gt;  # Pour les autres branches
            $ git pull  # Fetch + pull pour les branches correspondantes
            $ git push  # Envoie les données vers la branches distante correspondante
            $ git checkout -b origin/&lt;branch&gt;  # Récupère et tracke une branche distante
                        </code></pre>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p><i>git push</i> envoie les données locales sur le serveur distant.</p>
                        <pre><code>
                            $ git push  # Seulement les branches trackées
                            $ git push -u origin &lt;branch&gt; # Push une nouvelle branche
                            $ git push origin :&lt;branch&gt;  # Supprime une branche distante
                        </code></pre>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p>Évidemment, il faut avoir un droit le lecture / écriture sur le dépôt distant.</p>
                        <p>Il faut également que le dépôt local soit à jour.</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Organisation et workflows</h1>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Avec git, on peut créer autant qu'on veut de :</p>
                        <ul>
                            <li>branches locales ;</li>
                            <li>dépôts distants ;</li>
                            <li>branches distantes.</li>
                        </ul>
                        <p>Sans obligations de correspondances directes entre les uns et les autres.</p>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Du coup, ça peut vite devenir… b**lique.</p>
                        <ol>
                            <li>Comment organiser ses branches locales ?</li>
                            <li>Quel workflow pour le travail collaboratif ?</li>
                        </ol>
                        <p>Il n'y a pas de réponses unique, mais voici quelques pistes de réflexion.</p>
                    </section>

                    <section>
                        <h2>Organiser ses branches</h2>
                        <p>Journée classique d'un développeur :</p>
                        <ul>
                            <li>Je travaille sur un projet X</li>
                            <li>Depuis une semaine, je bosse sur la fonctionnalité Y, assez complexe</li>
                            <li>En parallèle, je dois résoudre un bug complexe avant la fin de la semaine</li>
                            <li>Zut ! le client remonte un bug, simple à corriger mais urgent</li>
                        </ul>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Exemples de mauvaises pratiques issues d'une habitude SVN :</p>
                        <ol>
                            <li>Travailler sur une seule branche (master) ;</li>
                            <li>Pusher trés régulièrement ;</li>
                            <li>Puller trés régulièrement ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Conséquences :</p>
                        <ol>
                            <li>La branche principale est potentiellement cassée ;</li>
                            <li>L'historique global est pourri de commits de fusion ;</li>
                            <li>Mes développements sont mélangés dans mon historique ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>Propositions de workflows</h2>
                        <p>Deux branches permanentes.</p>
                        <p><i>Master</i> contient le code déployé en production.</p>
                        <p><i>Dev</i> est la branche d'intégration.</p>
                        <pre><code>
                                        v1.0.0  v1.0.1
                                       /       /
                            o---------o-------o &#x2190; master
                                     /       /
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <p><i>Master</i> est <em>toujours</em> stable, et peut donc
                            servir pour déployer régulièrement (déploiement automatique).</p>
                        <p><i>Dev</i> contient tous les derniers développements, et
                            sert pour l'intégration continue (tests + builds).</p>
                    </section>

                    <section>
                        <h2>Développer des fonctionnalités</h2>
                        <pre><code>
                              o---o---o---o---o &#x2190; feature-login
                             /                 \
                            o---o-----------o---o---o  &#x2190; dev
                            |    \         /
                            |     o---o---o &#x2190; feature-newsletter
                             \
                              o---o---o---o &#x2190; feature-stupidtest
                        </code></pre>
                        <pre><code>
                            $ git checkout -b feature-login dev
                            $ Commit… Commit… Commit…
                            $ git checkout dev
                            $ git merge --no-ff feature-login
                            $ git branch -d feature-login
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer une <i>release</i></h2>
                        <pre><code>
                                                  v1.0.1
                                                 /
                            o---------o---------o &#x2190; master
                                               /
                                      o---o---o &#x2190; release-1.0.1
                                     /     \   \
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b release-1.0.1 dev
                            $ cat "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff release-1.0.1
                            $ git tag -a 1.0.1
                            $ git checkout dev
                            $ git merge --no-ff release-1.0.1
                            $ git branch -d release-1.0.1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Corriger un bug urgent</h2>
                        <pre><code>
                                                    v1.0.2
                                                   /
                            o---------o-----------o &#x2190; master
                                       \         /
                                        o---o---o &#x2190; hotfix-1.0.2
                                                 \
                              o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b hotfix-1.0.2 master
                            $ cat "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff hotfix-1.0.2
                            $ git tag -a 1.0.2
                            $ git checkout dev
                            $ git merge --no-ff hotfix-1.0.2
                            $ git branch -d hotfix-1.0.2
                        </code></pre>
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt centralisé</h3>
                        <p>Le plus simple pour démarrer.</p>
                        <img src="img/workflow1.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt d'intégration</h3>
                        <img src="img/workflow2.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le modèle « dictateur / lieutenants »</h3>
                        <p>Pour les trés gros projets.</p>
                        <img src="img/workflow3.png" />
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Nettoyer son historique</h1>
                        <h2>« Range ta chambre ! »</h2>
                    </section>

                    <section>
                        <h2>Avantages d'un historique bien propre</h2>
                        <ul>
                            <li>Lecture plus simple et rapide</li>
                            <li>Annulation de commits plus facile</li>
                            <li>Débuggage moins complexe</li>
                            <li>Partage de code et maintenance plus simple</li>
                            <li>Faciliter les fusions</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Rappel imporant</h2>
                        <blockquote>
                            « L'historique partagé jamais tu ne modifieras, sinon de toi et ton équipe
                              le malheur s'emparera » — Yoda.
                        </blockquote>
                    </section>

                    <section>
                        <h2>Commiter avec soin</h2>
                        <pre><code>
                            $ git commit -i
                            $ git add -p
                        </code></pre>
                    </section>

                    <section>
                        <h2>Réparer un commit</h2>
                        <pre><code>
                            $ git commit --amend  # Remplace le commit existant
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer les derniers commits</h2>
                        <pre><code>
                                              master &#x2190; HEAD
                                             /
                            A---B---C---D---E
                        </code></pre>
                        <pre><code>
                            $ git reset HEAD~3  # Reset le HEAD
                        </code></pre>
                        <pre><code>
                                  master &#x2190; HEAD
                                 /
                            A---B---C---D---E
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer un fichier</h2>
                        <pre><code>
    $ git rm --cached  # Supprime du HEAD
    $ git reset HEAD &lt;file&gt; # Supprime du staging
    $ # Pour les fichiers sensibles (à éviter si possible)
    $ git filter-branch --index-filter 'git rm --cached --ignore-unmatch &lt;file&gt;' \
        --prune-empty --tag-name-filter cat -- --all
    $ git push --all --force  # Vos collègues vous détesteront
                        </code></pre>
                    </section>

                    <section>
                        <h2>Récupérer un seul commit d'une autre branche</h2>
                        <pre><code>
                            $ git cherry-pick &lt;sha1&gt;
                        </code></pre>

                    </section>

                    <section>
                        <h2>L'artillerie lourde</h2>
                        <pre><code>
                    $ git rebase -i --onto &lt;destination&gt; &lt;upstream&gt; &lt;branch&gt;
                        </code></pre>
                        <p>Le rebase interactif permet de modifier, réordonner, découper, fusionner des commits.</p>
                        <pre><code>
                    $ git rebase -i HEAD~5  # Réécrire les 5 derniers commits
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Débugging avec git</h1>
                    </section>

                    <section>
                        <h2>Git blame</h2>
                        <p>Qui a fait ça ?!</p>
                        <pre><code>
                            $ git blame &lt;file&gt;
                            $ git blame &lt;file&gt; -L 50,55
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git bisect</h2>
                        <p>Recherche dichotomique de régression.</p>
                        <pre><code>
                            $ git bisect start
                            $ git bisect bad
                            $ git bisect good &lt;bon_commit&gt;
                            $ git bisect [bad|good|skip]  # Repeat
                            $ git bisect reset
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Git sur le serveur</h1>
                    </section>

                    <section>
                        <h2>Rappel : protocoles de partage</h2>
                        <ul>
                            <li>SSH : authentifié, lecture + écriture ;</li>
                            <li>Git : Lecture seulement, aucuns droits d'accès ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Créer un dépôt sur le serveur</h2>
                        <pre><code>
                            $ git init --bare repository_name.git
                            $ # ou
                            $ git clone --bare &lt;repository&gt; repository_name.git
                        </code></pre>
                        <p>Un <i>bare repository</i> est un dépôt uniquement dédié au partage :
                            il ne contient pas de WD.</p>
                        <p>Deux solutions : créer le dépôt sur le serveur, ou l'envoyer après coup (scp).</p>
                    </section>

                    <section>
                        <h2>Et c'est tout !</h2>
                        <p>Vos développeurs ont accès SSH sur un serveur quelconque ?</p>
                        <p>Placez-y un dépôt <i>bare</i>, et c'est tout bon.</p>
                    </section>

                    <section>
                        <h2>Configuration du serveur</h2>
                        <p>Première solution : créer un compte utilisateur pour chaque développeur sur le serveur.</p>
                        <p>Deuxième solution : créer un seul utilisateur <i>git</i>.</p>
                    </section>

                    <section>
                        <h2>Rappel : authentification par clés publiques</h2>
                        <pre><code>
                            $ ssh-keygen -t dsa
                            $ ssh-copy-id -i .ssh/id_dsa.pub git@git.serveur.com
                        </code></pre>
                        <p>Vous pouvez restreindre l'utilisateur aux commandes git en
                            lui assignant un shell spécial dans <i>/etc/passwd</i>.</p>
                        <pre><code>
                            git:x:1000:1000::/home/git:/usr/bin/git-shell
                        </code></pre>
                    </section>

                    <section>
                        <h2>Initialisation du dépôt</h2>
                        <pre><code>
        $ git clone ssh://git@git.serveur.com:/path/to/repository.git
        $ # ou
        $ git init
        $ Commit…
        $ git remote add origin ssh://git@git.serveur.com:/path/to/repository.git
        $ git push origin master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Autres solutions</h2>
                        <p>Gitosis : obsolète, dernier commit date de 4 ans ;</p>
                        <p>Gitolite : gère les permissions de manière fine ;</p>
                        <p>Git Daemon : pour un accès public read-only ;</p>
                        <p>Git Web : pour un accès http (mais pourquoi ?!) ;</p>
                    </section>

                    <section>
                        <h2>Github</h2>
                        <p>Faites plaisir à vos développeurs.
                            Github est devenu en quelques années un des principaux outils du monde du
                            développement.</p>
                        <p>Un peu comme un Facebook pour codeurs.</p>
                        <ul>
                            <li>Hébergement de dépôts gits</li>
                            <li>Dépôts publics / privés</li>
                            <li>Wiki</li>
                            <li>Bug tracker</li>
                            <li>Pull requests</li>
                            <li>Plans entrerpises</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Quelques commandes en détails</h1>
                    </section>

                    <section>
                        <h2>Git stash</h2>
                        <p>Je suis en plein milieu du dev, mais je dois faire un commit / merge / autre chose.</p>
                        <pre><code>
        $ git stash  # Met de côté les modifications en cours
        $ git stash save Message détaillé  # Idem, mais avec un message
        $ git stash list  # Liste les stashs disponibles
        $ git stash pop  # Applique les dernier stash
        $ git stash pop --index  # Idem, mais prend en compte le staging
        $ git stash branch  # Créé une branche depuis le commit initial
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git reset</h2>
                        <pre><code>
        Premier mode : reset sur un commit (HEAD si non spécifié)
        $ git reset --soft &lt;commit&gt;  # Déplace le HEAD *et* la branche sur &lt;commit&gt;
        $ git reset --mixed &lt;commit&gt;  # Idem, mais copie HEAD dans le staging
        $ git reset --hard &lt;commit&gt;   # Les deux premiers, mais copie HEAD dans le WD
                        </code></pre>
                        <pre><code>
        Deuxième mode : reset vers un chemin (idem, HEAD si commit non spécifié)
        $ git reset HEAD file.txt…
        Mêmes étapes que ci-dessus *mais* ne déplace pas le HEAD, et ne travaille que sur
        les fichiers / répertoires spécifiés.
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git checkout</h2>
                        <p>Contrairement à <i>git reset --hard</i>, <i>git checkout</i>
                           n'écrasera pas le WD en cas de risque de perte de données.</p>
                        <pre><code>
        $ git checkout &lt;commit&gt;
        # Déplace le HEAD (pas la branche) sur &lt;commit&gt;,
        et met à jour l'index et le WD *sauf* les fichiers modifiés (pfiou !)

        $ git checkout &lt;path&gt;
        # Met à jour le &lt;path&gt; du WD avec celui de l'index

        $ git checkout &lt;commit&gt; &lt;path&gt;
        # Met à jour le &lt;path&gt; du WD avec celui de &lt;commit&gt;
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Submodules et subtrees</h1>
                    </section>

                    <section>
                        <h2>Combiner des dépôts git</h2>
                        <p>Parfois, le besoin se fait sentir d'importer un dépôt git
                            dans un autre dépôt git.</p>
                        <p>Ex : bibliothèque.</p>
                        <p>Deux solutions : submodules et subtree.</p>
                    </section>

                    <section>
                        <h2>AVERTISSEMENT !</h2>
                        <p>Si vous pouvez l'éviter, faites-le !</p>
                        <p>Préférez utiliser les outils de votre langage pour lier
                            des projets ensembles.
                            Exemple : Virtualenv + pip + requirements.txt en Python.</p>
                        <p>Vous me remercierez plus tard.</p>
                    </section>

                    <section>
                        <h2>Les submodules</h2>
                        <p>Un submodule est un dépôt git dans un dépôt git.</p>
                        <p>Les dépôts sont liés mais restent indépendants.</p>
                        <pre><code>
            $ git submodule add https://github.com/twitter/bootstrap.git bootstrap
            $ git status
            $ cd bootstrap && git status
            $ cd ..
            $ cat .gitmodules
            $ git diff --cached bootstrap
                        </code></pre>
                    </section>

                    <section>
                        <h2>Modifier un submodule</h2>
                        <p>Une fois un sumbodule à jour (suite à un commit ou un merge),
                            il faut modifier la référence dans le projet principal,
                            et commiter.</p>
                    </section>

                    <section>
                        <h2>Attention aux pièges !</h2>
                        <pre><code>
            $ # Après avoir modifié un submodule, ne pas oublier de le pusher !
            $ git push --recurse-submodules=check
            $ # Après un git clone :
            $ git submodule init && git submodule update
            $ # Après un pull, si un submodule est modifié
            $ git submodule update
                        </code></pre>
                        <p>Et si le commit sur lequel pointe mon submodule n'est pas public ? Pas de bol !</p>
                        <p>Attention également aux changements de branche avec / sans submodules.</p>
                    </section>

                    <section>
                        <h2>Les subtrees</h2>
                        <p>Une solution alternative : dédier une branche distincte
                            pour le dépôt distant.</p>
                    </section>

                    <section>
                        <h2>Euh… Pardon ?</h2>
                        <pre><code>
            $ git remote add bootstrap_remote https://github.com/twitter/bootstrap.git
            $ git fetch bootstrap_remote
            $ git checkout -b bootstrap_branch bootstrap_remote/master
                        </code></pre>
                        <p>Vous voilà donc avec deux branches distinctes dont le contenu
                            est totalement différent.</p>
                        <p>Intégrons la nouvelle branche dans un sous répertoire de la première.</p>
                        <pre><code>
            $ git read-tree --prefix=bootstrap -u bootstrap_branch
                        </code></pre>
                    </section>

                    <section>
                        <h2>Euh… Pardon ?</h2>
                        <p>Récupérer le subtree distant :</p>
                        <pre><code>
                            $ git checkout bootstrap_branch
                            $ git pull
                            $ git checkout master
                            $ git merge --squash --no-commit -s subtree bootstrap_branch
                        </code></pre>
                        <p>Modifier le subtree local et pusher :</p>
                        <pre><code>
                            $ git checkout bootstrap_branch
                            $ git merge -s subtree master
                            $ git push
                        </code></pre>
                    </section>

                    <section>
                        <h2>Et mon diff ?</h2>
                        <pre><code>
                            $ git diff-tree -p bootstrap_branch
                            $ git diff-tree -p bootstrap_remote/master
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Les Hooks</h1>
                        <img src="http://www.linternaute.com/cinema/image_cache/objdbfilm/image/540/27222.jpg" />
                    </section>

                    <section>
                        <h2>Les hooks</h2>
                        <p>Un <i>hook</i> est un script prévu pour se déclencher à un moment précis.</p>
                        <pre><code>
                            $ ls .git/hooks
                        </code></pre>
                        <p>Les hooks peuvent être côté client ou côté serveur.</p>
                    </section>

                    <section>
                        <h2>Les hooks</h2>
                        <p>Exemples d'utilisation :</p>
                        <ul>
                            <li>vérifier que le message de commit respecte une certaine convention ;</li>
                            <li>vérifier les droits d'accès de certains fichiers ;</li>
                            <li>vérifer que les conventions de codage sont respectées ;</li>
                            <li>interdire de commiter des fichiers qui contiennent TODO, README, Fuck, etc. ;</li>
                            <li>lancer la mise en production après un push ;</li>
                            <li>interdire les commits après 17h ;</li>
                            <li>faire une bonne blague à un collègue ;</li>
                            <li>etc.</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Git et svn</h1>
                    </section>

                    <section>
                        <h2>Un comparatif Git / Svn</h2>
                        <p>Serait injuste pour SVN.</p>
                    </section>

                    <section>
                        <h2>Si vous aimez les antiquités…</h2>
                        <pre><code>
            $ aptitude install git-svn
            $ git-svn clone http://svn.example.com/svn/projet -T trunk projet
            $ cd projet
            $ git-svn show-ignore &gt;&gt; .git/info/exclude
            $ Commit… Commit… Commit…
            $ git svn rebase
            $ git svn dcommit
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fonctionnement interne de Git</h1>
                    </section>

                    <section>
                        <h2>Dans le cœur de la bête</h2>
                        <p>Tout le dépôt git se trouve dans <i>.git</i>.</p>
                        <pre><code>
                            config -> Configuration du dépôt
                            HEAD -> Pointeur vers le commit en cours
                            index -> Staging area
                            objects -> Base de données des objets
                            refs -> Pointeurs vers des commits
                        </code></pre>
                        <p>Les objets sont indexés par contenu : clé = sha1 hash du contenu.</p>
                    </section>

                    <section>
                        <h2>Les objets</h2>
                        <p>Git gère quatre types d'objets :</p>
                        <ul>
                            <li>blob : contenu d'un fichier ;</li>
                            <li>tree : liste d'objet et leurs meta-données (noms, permissions) ;</li>
                            <li>commit : référence vers un tree, meta-datas, un ou plusieurs commits parents ;</li>
                            <li>tag : les tags ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Les références</h2>
                        <p>Une référence est simplement une étiquette qui pointe vers un commit / une arborescence ;</p>
                    </section>

                    <section>
                        <h2>Les packfiles</h2>
                        <p>À chaque commit, Git stocke l'intégralité du fichier commité.</p>
                        <p>Périodiquement, Git empaquette les fichiers presque identiques pour gagner en espace et efficacité.</p>
                    </section>
                </section>

                <section>
                    <h1>{Biblio|Réseau}graphie</h1>
                    <ul>
                        <li><a href="http://git-scm.com/book">http://git-scm.com/book</a></li>
                        <li><a href="http://www.github.com">http://www.github.com</a></li>
                        <li><a href="http://gitready.com/">http://gitready.com/</a></li>
                    </ul>
                </section>

			</div>

		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: '../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: '../reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
