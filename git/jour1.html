<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Formation Git</title>

        <meta name="description" content="">
        <meta name="author" content="">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="../reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../reveal.js/css/theme/solarized.css" id="theme">
        <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">
        <link rel="stylesheet" href="css/styles.css">

        <!-- Uncomment this for printing -->
        <!--
        <link rel="stylesheet" href="../reveal.js/css/print/pdf.css" type="text/css">
        <link rel="stylesheet" href="../css/print/pdf.css" type="text/css">
        -->

        <style media="print">
            section > section {
                background: transparent url(img/bg.png) 0 100% no-repeat;
            }
        </style>

        <!--[if lt IE 9]>
        <script src="../reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <footer id="slide-footer"> Formation Git<br /> Thibault Jouannic <span>2014 ~ 2016</span> </footer>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <section>
                        <!--<img src="img/gros_logo.png" style="border: 0 !important; box-shadow: none !important; background: none !important; "/> -->
                        <h1>Formation Git</h1>
                    </section>

                    <section>
                        <h2>Thibault Jouannic</h2>
                        <p><a href="mailto:thibault@jouannic.fr">thibault@jouannic.fr</a> —
                        <a href="https://twitter.com/thibaultj">@thibaultj</a></p>
                        <ul>
                            <li><a href="http://miximum.fr">Miximum.fr</a></li>
                            <li>Développeur Web indépendant</li>
                            <li>Python, Django, Javascript</li>
                            <li>Plus de 7 ans d'utilisation quotidienne de Git</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Premier jour</h2>
                        <ul>
                            <li>Gestion de version : comment et pourquoi ?</li>
                            <li>Git — Concepts et fonctionnement</li>
                            <li>Avant de démarrer</li>
                            <li>Opérations basiques</li>
                            <li>Retrouver l'info</li>
                            <li>Les branches</li>
                            <li>Fusions de branches</li>
                            <li>Rebasing</li>
                            <li>Dépôts distants</li>
                            <li>Organisation et workflows</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Deuxième jour</h2>
                        <ul>
                            <li>Nettoyer son historique</li>
                            <li>Debugging avec git</li>
                            <li>Git sur le serveur</li>
                            <li>Quelques commandes en détails</li>
                            <li>Submodules et subtrees</li>
                            <li>Les hooks</li>
                            <li>Git et svn</li>
                            <li>Fonctionnement interne de git</li>
                            <li>Réseaugraphie</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Git — Introduction</h1>
                    </section>

                    <section>
                        <h2>L'histoire de Git</h2>
                        <p>BitKeeper, SCM non libre, était utilisé par Linus Torvalds pour développer le noyau Linux.</p>
                        <p>Quand les développeurs décident d'en révoquer le droit d'utilisation, Linus décide
                           de construire son propre outil.</p>
                        <p>Git est donc développé pour des projets à trés grande ampleur.</p>
                    </section>

                    <section>
                        <h2>Caractéristiques et prérequis</h2>
                        <p>Git est donc développé par des développeurs hautement expérimentés,
                           et avec de trés fortes exigeances.</p>
                        <ul>
                            <li>Haute performance</li>
                            <li>Architecture distribuée</li>
                            <li>Protection contre les corruptions et pertes de données</li>
                            <li>Support d'un <i>workflow</i> non linéaire</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Mais pourquoi est-il si génial ?</h2>
                        <ul>
                            <li>Chaque version de fichier est sauvegardée (pas les deltas)</li>
                            <li>Rapide comme l'éclair</li>
                            <li>Fonctionne en local</li>
                            <li>Quasiment impossible de perdre des données</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Bon, tout n'est pas parfait non plus</h2>
                        <ul>
                            <li>Des commandes aux multiples options ;</li>
                            <li>Des commandes qui ont l'air de faire plusieurs choses ;</li>
                            <li>Une syntaxe qui semble manquer (parfois) de cohérence ;</li>
                            <li>Une certaine complexité (qui n'est qu'apparente) ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Essayons !</h2>
                        <pre><code>
                            $ mkdir test && cd test
                            $ git init
                            $ touch file
                            $ git status
                            $ git add file
                            $ git status
                            $ git commit -a -m "First commit"
                            $ git status
                            $ git log
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Concepts et fonctionnement</h1>
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <img src="img/git_imgs/git_project.png" alt="" />
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <img src="img/git_imgs/git_workflow.png" alt="" />
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Avant de démarrer</h1>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <ul>
                            <li>/etc/gitconfig</li>
                            <li>~/.gitconfig</li>
                            <li>.git/config</li>
                        </ul>
                </section>

                <section>
                        <h2>Éditer le fichier de conf</h2>
                        <pre><code>
                            $ git config -e
                            $ git config --global -e
                        </code></pre>
                    </section>

                    <section>
                        <h2>Configurer un paramètre</h2>
                        <pre><code>
    $ git config --global user.name "Thibault Jouannic"
    $ git config --global user.email "thibault@miximum.fr"
    $ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer un paramètre</h2>
                        <pre><code>
    $ git config --unset diff.renames
                        </code></pre>
                    </section>

                    <section>
                        <h2>Lister les paramètres configurés</h2>
                        <pre><code>
    $ git config --list --show-origin
                        </code></pre>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <pre><code>
[user]
     mail = thibault@miximum.fr
    name = Thibault Jouannic
[color]
    ui = true
[alias]
    lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all
[push]
    default = current
[pull]
    rebase = preserve
[merge]
    tool = meld
    conflictstyle = diff3
[diff]
    compactionHeuristic = true
    renames = true
                        </code></pre>
                        <a href="https://gist.githubusercontent.com/thibault/d8699324637dad33bec50741ad3910d1/raw/198c029252bfa2492da6ea1aeb7791e6f1b59bf6/.gitconfig">
                            À télécharger ici
                        </a>
                    </section>

                    <section>
                        <h2>Prompt et complétion</h2>
                        <p>Un prompt personnalisé permet de disposer d'informations utiles
                            directement.</p>
                        <p><a href="https://github.com/git/git/tree/master/contrib/completion">https://github.com/git/git/tree/master/contrib/completion</a></p>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Récupérez le .gitconfig sample</li>
                            <li>https://raw.githubusercontent.com/thibault/prez/master/git/gitconfig</li>
                            <li>Enregistrez-le à l'emplacement adéquat</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Opérations basiques</h1>
                    </section>

                    <section>
                        <h2>Premier dépôt</h2>
                        <p>Créer un nouveau dépôt</p>
                        <pre><code>$ git init</code></pre>
                        <p>Cloner un dépôt distant<p>
                        <pre><code>$ git clone https://github.com/thibault/iwantyoursocks.git</code></pre>
                    </section>

                    <section>
                        <h2>.gitignore</h2>
                        <p>Pour ignorer certains fichiers.</p>
                        <p><a href="https://github.com/github/gitignore">Nombreux exemples sur https://github.com/github/gitignore</a></p>
                        <pre><code>
*.pyc
cache/
.DS_Store?
ehthumbs.db
Icon?
Thumbs.db
*.swp
.*.swp
*~
*.lock
*.out
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer le commit</h2>
                        <pre><code>
$ # WD &#x2192; Staging
$ git add .  # Ajoute tous les fichiers sous le dir. courant
$ git add &lt;file&gt;  # Ajoute un seul fichier ou dir.
$ git add -u  # Ignore les fichiers non trackés, enregistre la suppr. de fichiers
$ git add -f  # Ajout de fichiers ignorés
$ git add -i  # Interactif KILLER FEATURE!
$ git add -p &lt;file&gt;  # Mode patch directement
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <pre><code>
$ # Staging &#x2192; Repository
$ git commit  # Commit et lance l'éditeur pour saisir le message
$ git commit -m "Mon message"
$ git commit -a  # Tout commiter, même ce qui n'est pas dans le staging
$ git commit -am "Mon message"  # Svn style, à éviter bien évidemment
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <img src="img/git_imgs/git_graph.gif" alt="" />
                    </section>

                    <section>
                        <h2>Visualiser l'état du dépôt</h2>
                        <pre><code>
$ # HEAD &#x2260; Staging &#x2260; WD
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD file..." to unstage)
#
#    modified:   index.html
#
# Changes not staged for commit:
#   (use "git add file..." to update what will be committed)
#   (use "git checkout -- file..." to discard changes in working directory)
#
#    modified:   index.html
#
# Untracked files:
#   (use "git add file..." to include in what will be committed)
#
#    img
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer et déplacer des fichiers</h2>
                        <pre><code>
$ git rm &lt;file&gt; # Supprimer du repository et du WD
$ git rm --cached  &lt;file&gt; # Supprimer du repository mais pas du WD
$ git mv source destination  # Déplace un fichier
                        </code></pre>
                    </section>

                    <section>
                        <h2>Sortir des fichiers du staging</h2>
                        <pre><code>
$ git reset HEAD file  # Égal la commande suivante :
$ git reset file  # Copie la dernière version commitée dans le staging
$ git reset -p  # La même, en interactif
$ # Ces trois dernières commandes ne touchent pas au WD
                        </code></pre>
                        <p><i>git reset</i> peut faire bien plus, comme nous
                            allons le voir plus tard.</p>
                    </section>

                    <section>
                        <h2>Annuler les modifications d'un fichier</h2>
                        <pre><code>
$ git checkout file  # Copie la version staging de file dans le WD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Annuler un commit</h2>
                        <p>Attention, il existe plusieurs méthodes. git revert créé un commit opposé à un commit existant.</p>
                        <pre><code>
$ git revert commit
$ git revert commit -n  # Annule un commit mais attends votre validation pour commiter
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Cloner le dépôt du TP.</li>
                            <li>https://github.com/thibault/iwantyoursocks.git</li>
                            <li>Créer un nouveau fichier vide « CONTRIBUTORS » et commiter.</li>
                            <li>Ajouter votre nom et commiter de nouveau.</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Retrouver l'info</h1>
                    </section>

                    <section>
                        <h2>Voir les différences entre deux états</h2>
                        <pre><code>
$ git diff  # Montre les différences entre le WD et le staging
$ git diff &lt;file&gt;  # Limite à un seul fichier ou chemin
$ git diff --cached  # Différences entre staging et HEAD
$ git diff HEAD  # Différences entre le WD et HEAD
$ git diff &lt;commit&gt;  # Différences avec un commit / branch particulier
$ git diff &lt;commit&gt; &lt;commit&gt; # Différences entre deux commits
$ git diff --word-diff  # Différences mot à mot (au lieu de ligne à ligne)
$ git diff -w  # Ignore les espaces dans la comparaison
                        </code></pre>
                    </section>

                    <section>
                        <h2>Fouiller l'historique</h2>
                        <pre><code>
$ git log
$ git log -p
$ git log &lt;branch&gt;
$ git log --author=Thibault
$ git log --grep=keyword -i -E
$ git log --graph
$ git log --format=oneline
$ git log --since="yesterday"
$ git log --since="1 hour ago"
$ git log --name-only
$ git lg
                        </code></pre>
                    </section>

                    <section>
                        <h2>Voir des objets git</h2>
                        <pre><code>
$ git show  # Voir le dernier commit
$ git show &lt;commit&gt;
$ git show &lt;blob&gt;
$ git show &lt;tag&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un commit / révision</h2>
                        <pre><code>
$ git … HEAD
$ git … HEAD^
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8^^
$ git … efc95~3
$ git … hotfixes
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un intervalle de commits</h2>
                        <pre><code>
$ git log efc95493798d8..
$ git log efc95493798d8..efc95493798d8~5
$ git log HEAD~5..
$ git log -5  # Pareil
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Afficher le log du dépôt</li>
                            <li>Afficher toutes les modifications qui ont impacté le fichier « index.md »</li>
                            <li>Afficher le log de tous les commits entre f4881ac et 4078c07</li>
                            <li>Afficher tous les commits qui contiennent le mot « menu »</li>
                            <li>Afficher le détail du commit « 1c1ce3d3db90b9edf2240028e027581ef6d878c2 »</li>
                            <li>Afficher toutes les modifications réalisées entre les commits f4881ac et 4078c07</li>
                            <li>Afficher les modifications du répertoire « _layouts » entre les tags v0.0.1 et v1.0.0</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Les branches</h1>
                        <p>Tatatiiiiinnn…</p>
                    </section>

                    <section>
                        <h2>Utilisez-les!</h2>
                        <p>Avec d'autres SCM, les branches sont lentes, complexes et pénibles à utiliser.</p>
                        <p>Pas avec Git ! Les branches sont un outil essentiel à maîtriser.</p>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <p>Uniquement une étiquette qui pointe sur un commit.</p>
                        <p>C'est tout ? C'est tout !</p>
                    </section>

                    <section>
                        <h2>La branche master</h2>
                        <img src="img/git_imgs/git_branch1.png" alt="" />
                    </section>

                    <section>
                        <h2>La branche master</h2>
                        <img src="img/git_imgs/git_branch2.png" alt="" />
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_create_branch_3.png" />
                        <pre><code>
                            $ git branch test
                            $ git checkout test
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_1.png" />
                        <pre><code>
                            Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_2.png" />
                        <pre><code>
                            $ git checkout master
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_3.png" />
                        <pre><code>
                            $ Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <p>Créer / supprimer une branche est… rapide !</p>
                        <p>Il est possible de créer une branche n'importe quand… même depuis un ancien commit !</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Oups, j'ai oublié de faire une branche.</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git branch new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                         \
                                          new_feature
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git reset --soft HEAD~2
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ Commit… Commit… Commit…
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  E---F---G &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git checkout new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand utiliser une branche ?</h2>
                        <ul>
                            <li>Pour isoler un développement un peu long</li>
                            <li>Pour faire des tests sans casser tout le dépôt</li>
                            <li>Pour mettre quelques commits de côté</li>
                            <li>Juste parce qu'on peut !</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Créer une branche</h2>
                        <pre><code>
                            $ git branch &lt;name&gt; && git checkout &lt;name&gt;
                            $ # ou, plus rapide
                            $ git checkout -b &lt;name&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Passer d'une branche à l'autre</h2>
                        <pre><code>
                            $ git checkout &lt;branch1&gt;
                            $ git checkout &lt;branch2&gt;
                            $ git checkout -
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer une branche</h2>
                        <pre><code>
                            $ git branch -d &lt;name&gt;
                            $ git branch -D &lt;name&gt;  # si branche non fusionnée
                        </code></pre>
                    </section>

                    <section>
                        <h2>Lister les branches</h2>
                        <pre><code>
                            $ git branch  # Lister les branches locales
                            $ git branch -r  # Lister les branches distantes
                            $ git branch -a  # Combine les deux
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Lister les branches locales du dépôt</li>
                            <li>Lister les branches distantes</li>
                            <li>Récupérer en local les branches « colors », « material » et « patterns »</li>
                            <li>Lister les branches fusionnées et non fusionnées</li>
                            <li>Passer sur la branche « colors »</li>
                            <li>Passer sur la branch « gh-pages »</li>
                            <li>Créer une nouvelle branche « quicktest », supprimer un fichier, commiter</li>
                            <li>Supprimer la branche « quicktest »</li>
                            <li>Supprimer la branch « patterns »</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fusions de branches</h1>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <p>Now… what?</p>
                    </section>

                    <section>
                        <h2>Pas de panique !</h2>
                        <p>Si vous avez déjà tenté une fusion avec SVN ou autre, il est
                           probable que vous soyez terrifié.</p>
                        <p>Avec Git, ça va bien se passer :)</p>
                    </section>

                    <section>
                        <h2>Avant la fusion…</h2>
                        <p>Il est important d'avoir un dépôt propre.</p>
                        <p>Tous les fichiers sont commités, le WD et l'index sont propres.</p>
                        <p>Placer le HEAD sur la branche principale.</p>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            A---B &#x2190; master &#x2190; HEAD
                                 \
                                  C---D---E &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                                             \
                                              hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git branch -d hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <p>Git rejoue les commits de <i>hotfix</i> sur master.</p>
                        <p>Le résultat est enregistré dans un commit qui a deux parents.</p>
                        <p>S'il n'y a pas de conflits, ce sera un commit vide.</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aah! les conflits…</h2>
                        <p>Il arrive qu'un merge ne puisse être réalisé automatiquement.</p>
                        <p>Ex : Le même fichier modifé différemment dans deux branches distinctes.</p>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Imaginons un fichier A, et ses différentes versions à travers le temps.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A7
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Git considère trois versions du fichier : les deux dernières versions, et
                           le dernier ancêtre commun.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A7
                        </code></pre>
                        <p>Ici, A2, A4 et A7.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p><i>git status</i> permet de voir les fichiers mergés avec succès, et les autres.</p>
                        <p><i>git log --merge -p</i> montre uniquement les commits qui impactent les fichiers à merger.</p>
                        <p><i>git show [:1,:2,:3]:&lt;file&gt;</i> montre les différentes versions du fichier.</p>
                        <p><i>git diff / git difftool</i> pour voir des différences.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Git modifie les fichiers conflictuels pour inclure des marqueurs de diff.</p>
                        <pre><code>
                            Cette ligne est la même dans les deux branches

                            <<<<<<< HEAD
                            Ajouté dans la branche master
                            =======
                            Ajouté dans la branche test
                            >>>>>>> test

                            Cette partie du fichier est commune
                        </code></pre>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Modifier le fichier pour résoudre les conflits.</p>
                        <p><i>git add</i> puis <i>git commit</i></p>
                        <p><i>git mergetool</i> permet de lancer un outil de résolution de merge.</p>
                    </section>

                    <section>
                        <h2>Git mergetool</h2>
                        <pre><code>
# voir les outils disponibles
git mergetool --tool-help

# configurer l'outil par défaut
git config --global merge.tool meld

# lancer l'outil de merge
git mergetool
                        </code></pre>
                    </section>

                    <section>
                        <h2>Que faire après un merge ?</h2>
                        <pre><code>
                            $ git branch --merged  # montre toutes les branches mergées
                            $ git branch -d &lt;bug_42&gt;  # supprime la branche
                            $ git branch --no-merged  # montre les branches non fusionnées
                        </code></pre>
                        <p>Même une fois fusionnée, une branche peut continuer à vivre. Un autre
                            merge pourra être réalisé plus tard.</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <p>Tentons l'expérience suivante :</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git branch -D hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Les commits de ma branche <i>hotfix</i> sont-ils perdus ?</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G
                        </code></pre>
                        <p>En fait, les commits existent toujours, ils sont simplement inaccessibles.</p>
                        <p>Au bout de quelques jours, ils seront supprimés par le <i>Garbage collector</i> de git.</p>
                    </section>

                    <section>
                        <h2>Le reflog</h2>
                        <p>Git garde une trace de tous les changements de position de HEAD.</p>
                        <pre><code>
                            $ git reflog
                            $ git checkout G
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; HEAD
                        </code></pre>
                        <p>Mais… HEAD pointe directement vers un commit ? Pas une branche ?</p>
                    </section>

                    <section>
                        <h2>L'état <i>Detached HEAD</i></h2>
                        <p>Quand HEAD pointe directement vers un commit, on parle de detached HEAD.
                           Pour retrouver une situation stable, il suffit de créer une branche,
                           et de continuer comme si de rien n'était.</p>
                        <pre><code>
                            $ git checkout -b newbranch
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; newbranch &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Retrouver l'identité du commit perdu sur « quicktest »</li>
                            <li>Fusionner la branche « material » dans « gh-pages »</li>
                            <li>Fusionner la branche « colors » dans « gh-pages »</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Rebasing</h1>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'un rebase ?</h2>
                        <p>Le rebase est une autre façon d'intégrer les modifications de
                            deux branches.</p>
                        <p><i>git rebase</i> réapplique les commits d'une branche sur
                            une autre base.</p>
                    </section>

                    <section>
                        <h2>Merge vs. Rebase</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>

                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git checkout hotfix && git rebase master
                        </code></pre>

                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; hotfix &#x2190; HEAD
                                         \
                                          master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment ça fonctionne ?</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <ol>
                            <li>git met de côté tous les commits de la branche <i>hotfix</i></li>
                            <li>l'étiquette <i>hotfix</i> est déplacée sur le dernier commit de <i>master</i></li>
                            <li>les commits de côté sont tous ré-appliqués <em>un par un</em></li>
                        </ol>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <ul>
                            <li>Le résultat est le même que le merge, mais l'historique est « plat »</li>
                            <li>Il n'y a pas de commits de fusion vide</li>
                            <li>Chaque commit peut provoquer un conflit</li>
                            <li>Les commits sont réécrits, ce ne sont pas les mêmes (ids différents)</li>
                        </ul>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand privilégier rebase sur merge ?</h2>
                        <ul>
                            <li>Soigner son historique</li>
                            <li>Rattraper un mauvais historique</li>
                            <li>Faciliter l'intégration de branches</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <p>Si l'on créé de petites branches en local, on se retrouve facilement
                            avec beaucoup de commits de fusion, et un historique difficile à lire.</p>
                        <pre><code>
                                      F---G &#x2190; bug2
                                     /
                            A---B---E---H---I &#x2190; master
                                 \
                                  C---D &#x2190; bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <pre><code>
                            $ git rebase master bug1
                            $ git checkout master && git merge bug1
                            $ git rebase master bug2
                            $ git checkout master && git merge bug2
                        </code></pre>
                        <pre><code>
                                                                 bug2
                                                                /
                            A---B---E---H---I---C'---D'---F'---G' &#x2190; master
                                                      \
                                                       bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <p>Je n'ai pas créé ma branche depuis le bon commit.</p>
                        <pre><code>
                            A---B---H---I---J &#x2190; production
                                 \
                                  C---D---G &#x2190; feature_en_cours
                                       \
                                        E---F &#x2190; bug_urgent
                        </code></pre>
                        <p>Et si je veux passer <i>bug_urgent</i> en production, mais
                            pas <i>feature_en_cours</i> ?</p>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <pre><code>
                            $ git rebase feature_en_cours bug_urgent --onto production
                        </code></pre>
                        <pre><code>
                            A---B---H---I---J---E'---F' &#x2190; production &#x2190; bug_urgent
                                 \
                                  C---D---G &#x2190; feature_en_cours
                        </code></pre>
                        <p>Les commits sont tous ceux qui sont dans <i>bug_urgent</i>
                            mais pas dans <i>feature_en_cours</i>.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            A---B &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_1
                                       \
                                        E---F &#x2190; bug_2
                        </code></pre>
                        <p>Oups ! bug_1 et bug_2 n'ont rien à voir.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            $ git rebase --onto production  bug_1 bug_2
                        </code></pre>
                        <pre><code>
                            A---B &#x2190; production
                                |\
                                | C---D---G &#x2190; bug_1
                                 \
                                   E'---F' &#x2190; bug_2

                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <p>Si je veux supprimer les commits C et D ?</p>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <pre><code>
                            $ git rebase --onto B D master
                            $ # Remplacer B et D par les sha1 des commits
                        </code></pre>
                        <pre><code>
                            A---B---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                 \
                                  E---F---G &#x2190; master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Faciliter l'intégratoin de branches au long cours</h2>
                        <pre><code>
    A---B---C---D--- … ---E---F---G ← master
      \
       H---I---J--- … ---K---L ← newsletter
                        </code></pre>
                        <pre><code>
    $ git rebase master newsletter
                        </code></pre>
                        <pre><code>
    A---B---C---D--- … ---E---F---G ← master
                                   \
                                    H---I---J--- … ---K---L ← newsletter
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            $ git pull --rebase
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                         \
                                          E'---F'---G' &#x2190; master local
                        </code></pre>
                        <pre><code>
                            $ git push
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master distant
                                                       \
                                                        master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Grands pouvoirs, grandes responsabilités</h2>
                        <p>si vous réécrivez l'historique d'une branche partagée,
                            vos collègues vous tremperont dans le goudron et les plumes.</p>
                        <p><i>git rebase</i> ne doit donc être utilisé que pour
                            les branches locales.</p>
                    </section>

                    <section>
                        <h2>Et si un rebase ne se passe pas bien ?</h2>
                        <p>Les commits sont réappliqués un par un. Il y a donc des
                            conflits potentiels.</p>
                        <pre><code>
                            $ git status  # Comprendre ce qui se passe
                            $ # régler le conflit, puis :
                            $ git rebase --continue  # reprendre le travail, ou
                            $ git rebase --abort  # Tout annuler, ou
                            $ git rebase --skip  # Continuer en laissant de côté ce commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Eh ! pssst !</h2>
                        <p>Pour frimer : git rerere</p>
                        <pre><code>
    $ git config --global rerere.enabled true
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Annuler les deux dernières fusions</li>
                            <li>Rebaser « material » sur « gh-pages » et la fusionner</li>
                            <li>Rebaser « colors » sur « gh-pages » et la fusionner</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Dépôts distants</h1>
                        <p>Parce qu'il faut bien partager le code à un moment ou à un autre.</p>
                    </section>

                    <section>
                        <h2>Git est décentralisé</h2>
                        <p>Rappel : git est un système décentralisé. Il n'y a pas
                            de notion de dépôt central.</p>
                        <p>Sauf par convention.</p>
                        <p>Il est donc possible de créer autant de dépôts distants
                            que nécessaire.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p>Si vous clonez un dépôt, git l'enregistre comme dépôt distant
                            dans le nouveau dépôt local.
                        </p>
                        <pre><code>
                            $ git clone …
                            $ git remote  # Lister les dépôts distants
                            $ git remote show origin  # Détail sur le dépôt distant
                        </code></pre>
                       <p>Par convention, le dépôt distant par défaut se nomme <i>origin</i>.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p><i>git remote</i> sert à gérer les dépôts distants.</p>
                        <pre><code>
                            $ git remote add &lt;name&gt; &lt;url&gt;  # Ajoute un nouveau remote
                            $ git remote rm …
                            $ git remote mv …
                            $ git help remote
                        </code></pre>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p>N'importe quel dépôt peut être utilisé comme dépôt distant !</p>
                        <ul>
                            <li>Un dépôt sur un autre serveur</li>
                            <li>Un autre dépôt sur votre propre machine</li>
                            <li>Le dépôt d'un·e collègue</li>
                            <li>…</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Protocoles de communication</h2>
                        <p>Un dépôt git peut être partagé via de nombreux protocoles. Parmi les plus courants :</p>
                        <ul>
                            <li>SSH : ssh://[user@]host.xz[:port]/path/to/repo.git/</li>
                            <li>(autre syntaxe) user@host.xz:repo.git/</li>
                            <li>GIT : git://host.xz[:port]/path/to/repo.git/</li>
                            <li>Filesystem : file:///path/to/repo.git</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <p>Une branche distante est une branche locale <i>read-only</i>
                            qui représente une branche sur le dépôt distant. Euh… wat ?
                        </p>
                        <pre><code>
                            $ git branch -a
                            * master
                            remotes/origin/master
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                         \
                                          master
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                     \
                                      master
                        </code></pre>
                        <pre><code>
                            A---B---C &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                        <pre><code>
                            A---B---C---E &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git fetch  # Télécharge les données du serveur
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D---G &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git merge / git rebase
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D---G &#x2190; origin/master
                                             \
                                              E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git pull / git pull --rebase
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches trackées ou non</h2>
                        <pre><code>
$ git pull

There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull &lt;remote&gt; &lt;branch&gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt; &lt;branch&gt;


$ git pull origin testing
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches trackées ou non</h2>
                        <p>Toutes les branches locales n'ont pas à être sur le serveur, et
                            vice-versa.</p>
                        <p>Une <i>branche trackée</i> est une branche locale qui a
                            une relation directe avec une branche distante.</p>
                        <pre><code>
            $ git fetch  # Ne télécharge que les branches trackées de origin
            $ git fetch origin &lt;branch&gt;  # Pour les autres branches
            $ git pull  # Fetch + merge
            $ git push  # Envoie les données vers la branches distante correspondante
            # cf. git push.default
                        </code></pre>
                    </section>

                    <section>
                        <h2>Configurer les informations de tracking</h2>
                        <p>En créant la branche :</p>
                        <pre><code>
            $ git checkout -b branch origin/&lt;branch&gt;  # Récupère et tracke une branche distante
            $ git checkout -t origin/&lt;branch&gt;  # même chose, mais plus court
                        </code></pre>

                        <p>Après coup :</p>
                        <pre><code>
            $ git branch branch && git checkout branch
            $ git branch -u upstream/branch
                        </code></pre>
                    </section>

                    <section>
                        <h2>Configurer les informations de tracking</h2>
                        <pre><code>
$ git branch -vv
* mapping ff1571d Merge branch 'master' into mapping
  master  d11d11c [origin/master] Proper call to super() in BoolMixin.
                        </code></pre>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p><i>git push</i> envoie les données locales sur le serveur distant.</p>
                        <pre><code>
                            $ git push  # Seulement les branches trackées
                            $ git push origin &lt;branch&gt; # Push une nouvelle branche
                            $ git push origin :&lt;branch&gt;  # Supprime une branche distante
                        </code></pre>
                        <p>Cf. git help config -> push.default</p>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p>Évidemment, il faut avoir un droit le lecture / écriture sur le dépôt distant.</p>
                        <p>Il faut également que le dépôt local soit à jour.</p>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Créer un nouveau dépôt « bare » en clonant le dépôt Github</li>
                            <li>Dans le dépôt initial, configurer le nouveau dépôt comme dépôt distant</li>
                            <li>Télécharger les données du nouveau dépôt</li>
                            <li>« pusher » votre branche gh-pages à jour</li>
                            <li>Configurer « gh-pages » pour tracker la branche sur le nouveau distant</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Organisation et workflows</h1>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Avec git, on peut créer autant qu'on veut de :</p>
                        <ul>
                            <li>branches locales ;</li>
                            <li>dépôts distants ;</li>
                            <li>branches distantes.</li>
                        </ul>
                        <p>Sans obligations de correspondances directes entre les uns et les autres.</p>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Du coup, ça peut vite devenir… b**lique.</p>
                        <ol>
                            <li>Comment organiser ses branches locales ?</li>
                            <li>Quel workflow pour le travail collaboratif ?</li>
                        </ol>
                        <p>Il n'y a pas de réponses unique, mais voici quelques pistes de réflexion.</p>
                    </section>

                    <section>
                        <h2>Organiser ses branches</h2>
                        <p>Journée classique d'un développeur :</p>
                        <ul>
                            <li>Je travaille sur un projet X</li>
                            <li>Depuis une semaine, je bosse sur la fonctionnalité Y, assez complexe</li>
                            <li>En parallèle, je dois résoudre un bug complexe avant la fin de la semaine</li>
                            <li>Zut ! le client remonte un bug, simple à corriger mais urgent</li>
                        </ul>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Exemples de mauvaises pratiques issues d'une habitude SVN :</p>
                        <ol>
                            <li>Travailler sur une seule branche (master) ;</li>
                            <li>Pusher trés régulièrement ;</li>
                            <li>Puller trés régulièrement ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Conséquences :</p>
                        <ol>
                            <li>La branche principale est potentiellement cassée ;</li>
                            <li>L'historique global est pourri de commits de fusion ;</li>
                            <li>Mes développements sont mélangés dans mon historique ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>Propositions de workflows</h2>
                        <p>Deux branches permanentes.</p>
                        <p><i>Master</i> contient le code déployé en production.</p>
                        <p><i>Dev</i> est la branche d'intégration.</p>
                        <pre><code>
                                        v1.0.0  v1.0.1
                                       /       /
                            o---------o-------o &#x2190; master
                                     /       /
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <p><i>Master</i> est <em>toujours</em> stable, et peut donc
                            servir pour déployer régulièrement (déploiement automatique).</p>
                        <p><i>Dev</i> contient tous les derniers développements, et
                            sert pour l'intégration continue (tests + builds).</p>
                    </section>

                    <section>
                        <h2>Développer des fonctionnalités</h2>
                        <pre><code>
                              o---o---o---o---o &#x2190; feature-login
                             /                 \
                            o---o-----------o---o---o  &#x2190; dev
                            |    \         /
                            |     o---o---o &#x2190; feature-newsletter
                             \
                              o---o---o---o &#x2190; feature-stupidtest
                        </code></pre>
                        <pre><code>
                            $ git checkout -b feature-login dev
                            $ Commit… Commit… Commit…
                            $ git checkout dev
                            $ git merge --no-ff feature-login
                            $ git branch -d feature-login
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer une <i>release</i></h2>
                        <pre><code>
                                                  v1.0.1
                                                 /
                            o---------o---------o &#x2190; master
                                               /
                                      o---o---o &#x2190; release-1.0.1
                                     /     \   \
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b release-1.0.1 dev
                            $ echo "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff release-1.0.1
                            $ git tag -a 1.0.1
                            $ git checkout dev
                            $ git merge --no-ff release-1.0.1
                            $ git branch -d release-1.0.1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Corriger un bug urgent</h2>
                        <pre><code>
                                                    v1.0.2
                                                   /
                            o---------o-----------o &#x2190; master
                                       \         /
                                        o---o---o &#x2190; hotfix-1.0.2
                                                 \
                              o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b hotfix-1.0.2 master
                            $ echo "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff hotfix-1.0.2
                            $ git tag -a 1.0.2
                            $ git checkout dev
                            $ git merge --no-ff hotfix-1.0.2
                            $ git branch -d hotfix-1.0.2
                        </code></pre>
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt centralisé</h3>
                        <p>Le plus simple pour démarrer.</p>
                        <img src="img/workflow1.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt d'intégration</h3>
                        <img src="img/workflow2.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le modèle « dictateur / lieutenants »</h3>
                        <img src="img/workflow3.png" />
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Préparer la release de la version 1.0.1 et fusionner</li>
                            <li>Trouver une faute à corriger, et créer une version 1.0.2</li>
                            <li>Pusher vos nouveaux tags sur le serveur</li>
                        </ul>
                    </section>
                </section>
            </div>

        </div>

        <script src="../reveal.js/lib/js/head.min.js"></script>
        <script src="../reveal.js/js/reveal.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                rollingLinks: false,
                margin: 0,
                slideNumber: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });
        </script>
    </body>
</html>
