<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Formation Git</title>

        <meta name="description" content="">
        <meta name="author" content="">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
        <link rel="stylesheet" href="../reveal.js/css/theme/solarized.css" id="theme">
        <link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">
        <link rel="stylesheet" href="css/styles.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            document.write( '<link rel="stylesheet" href="../reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
            document.write( '<link rel="stylesheet" href="../css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>

        <style media="print">
            section > section {
                background: transparent url(img/bg.png) 0 100% no-repeat;
            }
        </style>

        <!--[if lt IE 9]>
        <script src="../reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <footer id="slide-footer"> Formation Git<br /> Thibault Jouannic <span>2014</span> </footer>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section>
                    <section>
                        <img src="img/gros_logo.png" style="border: 0 !important; box-shadow: none !important; background: none !important; "/>
                        <h1>Formation Git</h1>
                    </section>

                    <section>
                        <h2>Thibault Jouannic</h2>
                        <p><a href="mailto:thibault@jouannic.fr">thibault@jouannic.fr</a> —
                        <a href="https://twitter.com/thibaultj">@thibaultj</a></p>
                        <ul>
                            <li>Développeur Web indépendant</li>
                            <li>Python, Django, Javascript</li>
                            <li>Plus de 5 ans d'utilisation quotidienne de Git</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Premier jour</h2>
                        <ul>
                            <li>Gestion de version : comment et pourquoi ?</li>
                            <li>Git — Concepts et fonctionnement</li>
                            <li>Avant de démarrer</li>
                            <li>Opérations basiques</li>
                            <li>Retrouver l'info</li>
                            <li>Les branches</li>
                            <li>Fusions de branches</li>
                            <li>Rebasing</li>
                            <li>Dépôts distants</li>
                            <li>Organisation et workflows</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Deuxième jour</h2>
                        <ul>
                            <li>Nettoyer son historique</li>
                            <li>Debugging avec git</li>
                            <li>Git sur le serveur</li>
                            <li>Quelques commandes en détails</li>
                            <li>Submodules et subtrees</li>
                            <li>Les hooks</li>
                            <li>Git et svn</li>
                            <li>Fonctionnement interne de git</li>
                            <li>Réseaugraphie</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Git — Introduction</h1>
                    </section>

                    <section>
                        <h2>L'histoire de Git</h2>
                        <p>BitKeeper, SCM non libre, était utilisé par Linus Torvalds pour développer le noyau Linux.</p>
                        <p>Quand les développeurs décident d'en révoquer le droit d'utilisation, Linus décide
                           de construire son propre outil.</p>
                        <p>Git est donc développé pour des projets à trés grande ampleur.</p>
                    </section>

                    <section>
                        <h2>Caractéristiques et prérequis</h2>
                        <p>Git est donc développé par des développeurs hautement expérimentés,
                           et avec de trés fortes exigeances.</p>
                        <ul>
                            <li>Haute performance</li>
                            <li>Architecture distribuée</li>
                            <li>Protection contre les corruptions et pertes de données</li>
                            <li>Support d'un <i>workflow</i> non linéaire</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Mais pourquoi est-il si génial ?</h2>
                        <ul>
                            <li>Chaque version de fichier est sauvegardée (pas les deltas)</li>
                            <li>Rapide comme l'éclair</li>
                            <li>Fonctionne en local</li>
                            <li>Quasiment impossible de perdre des données</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Bon, tout n'est pas parfait non plus</h2>
                        <ul>
                            <li>Des commandes aux multiples options ;</li>
                            <li>Des commandes qui ont l'air de faire plusieurs choses ;</li>
                            <li>Une syntaxe qui semble manquer (parfois) de cohérence ;</li>
                            <li>Une certaine complexité (qui n'est qu'apparente) ;</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Essayons !</h2>
                        <pre><code>
                            $ mkdir test && cd test
                            $ git init
                            $ touch file
                            $ git status
                            $ git add file
                            $ git status
                            $ git commit -a -m "First commit"
                            $ git status
                            $ git log
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Concepts et fonctionnement</h1>
                    </section>

                    <section>
                        <h2>Deux stuctures de données</h2>
                        <p>La base de données d'objets : toute modification s'apparente à un ajout à la base.
                            Chaque objet est indexé par son hash SHA1.</p>
                        <p>L'index mutable (<i>Stage</i> ou <i>Cache</i>) qui contient les infos sur
                            le répertoire de travail et le prochain commit.</p>
                    </section>

                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Dépôt</dt>
                            <dd>Ensemble des données et meta-données d'un projet géré sous git</dd>
                            <dt>Working directory (WD)</dt>
                            <dd>Ensemble local des fichiers et répertoires du projet</dd>
                            <dt>Commit</dt>
                            <dd>Enregistrement daté d'une modification du WD</dd>
                            <dt>Index / Staging area</dt>
                            <dd>Liste des modifications à commiter</dd>
                            <dt>Branche</dt>
                            <dd>Flux de commits parallèle.</dd>
                            <dt>Master</dt>
                            <dd>Branche principale du dépôt</dd>
                        </dl>
                    </section>

                    <section>
                        <h2>Vocabulaire</h2>
                        <dl>
                            <dt>Tag</dt>
                            <dd>Étiquette désignant un commit précis</dd>
                            <dt>Fusion / Merge</dt>
                            <dd>Action de combiner les commits de plusieurs branches</dd>
                            <dt>Conflit</dt>
                            <dd>Incompatibilité empêchant une fusion automatique</dd>
                            <dt>HEAD</dt>
                            <dd>Désigne le dernier commit de la branche courante</dd>
                            <dt>ORIG_HEAD</dt>
                            <dd>La précédente position de HEAD</dd>
                        </dl>
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <img src="img/git_imgs/git_project.png" alt="" />
                    </section>

                    <section>
                        <h2>Zones et états</h2>
                        <img src="img/git_imgs/git_workflow.png" alt="" />
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Avant de démarrer</h1>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <ul>
                            <li>/etc/gitconfig</li>
                            <li>~/.gitconfig</li>
                            <li>.git/config</li>
                        </ul>
                        <pre><code>
$ git config --global user.name "Thibault Jouannic"
$ git config --global user.email "thibault@miximum.fr"
                        </code></pre>
                    </section>

                    <section>
                        <h2>La configuration</h2>
                        <pre><code>
[user]
    name = Thibault Jouannic
    email = thibault@miximum.fr
[color]
    ui = true
[alias]
    lg = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
    st = status
    ci = commit
[core]
    editor = vim
[merge]
    tool = vimdiff
                        </code></pre>
                    </section>

                    <section>
                        <h2>Prompt et complétion</h2>
                        <p>Un prompt personnalisé permet de disposer d'informations utiles
                            directement.</p>
                        <p><a href="https://github.com/git/git/tree/master/contrib/completion">https://github.com/git/git/tree/master/contrib/completion</a></p>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Récupérez le .gitconfig sample</li>
                            <li>https://github.com/thibault/prez/blob/master/git/gitconfig</li>
                            <li>Enregistrez-le à l'emplacement adéquat</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Opérations basiques</h1>
                    </section>

                    <section>
                        <h2>Premier dépôt</h2>
                        <p>Créer un nouveau dépôt</p>
                        <pre><code>$ git init</code></pre>
                        <p>Cloner un dépôt distant<p>
                        <pre><code>$ git clone https://github.com/thibault/prez.git</code></pre>
                    </section>

                    <section>
                        <h2>.gitignore</h2>
                        <p>Pour ignorer certains fichiers.</p>
                        <p><a href="https://gist.github.com/thibault/5804127">Exemple de .gitignore</a>
                        <pre><code>
*.pyc
cache/
.DS_Store?
ehthumbs.db
Icon?
Thumbs.db
*.swp
.*.swp
*~
*.lock
*.out
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer le commit</h2>
                        <pre><code>
$ # WD &#x2192; Staging
$ git add .  # Ajoute tous les fichiers sous le dir. courant
$ git add &lt;file&gt;  # Ajoute un seul fichier ou dir.
$ git add -u  # Ignore les fichiers non trackés, enregistre la suppr. de fichiers
$ git add -f  # Ajout de fichiers ignorés
$ git add -p / git add -i  # Interactif KILLER FEATURE!
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <pre><code>
$ # Staging &#x2192; Repository
$ git commit  # Commit et lance l'éditeur pour saisir le message
$ git commit -m "Mon message"
$ git commit -a  # Tout commiter, même ce qui n'est pas dans le staging
$ git commit -am "Mon message"  # Svn style
                        </code></pre>
                    </section>

                    <section>
                        <h2>Commiter</h2>
                        <img src="img/git_imgs/git_graph.gif" alt="" />
                    </section>

                    <section>
                        <h2>Visualiser l'état du dépôt</h2>
                        <pre><code>
$ # HEAD &#x2260; Staging &#x2260; WD
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD file..." to unstage)
#
#    modified:   index.html
#
# Changes not staged for commit:
#   (use "git add file..." to update what will be committed)
#   (use "git checkout -- file..." to discard changes in working directory)
#
#    modified:   index.html
#
# Untracked files:
#   (use "git add file..." to include in what will be committed)
#
#    img
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer et déplacer des fichiers</h2>
                        <pre><code>
$ git rm  # Supprimer du repository et du WD
$ git rm --cached  # Supprimer du repository mais pas du WD
$ git mv source destination  # Déplace un fichier
                        </code></pre>
                    </section>

                    <section>
                        <h2>Sortir des fichiers du staging</h2>
                        <pre><code>
$ git reset HEAD file  # Égal la commande suivante :
$ git reset file  # Copie la dernière version commitée dans le staging
$ git reset -p  # La même, en interactif
$ # Ces trois dernières commandes ne touchent pas au WD
                        </code></pre>
                        <p><i>git reset</i> peut faire bien plus, comme nous
                            allons le voir plus tard.</p>
                    </section>

                    <section>
                        <h2>Annuler les modifications d'un fichier</h2>
                        <pre><code>
$ git checkout file  # Copie la version staging de file dans le WD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Annuler un commit</h2>
                        <p>Attention, il existe plusieurs méthodes. git revert créé un commit opposé à un commit existant.</p>
                        <pre><code>
$ git revert commit
$ git revert commit -n  # Annule un commit mais attends votre validation pour commiter
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Clonez le dépôt tpgit</li>
                            <li>git clone https://github.com/thibault/tpgit/</li>
                            <li>Modifiez un fichier existant et commitez</li>
                            <li>Créez un fichier et commitez</li>
                        </ul>
                    </section>

                </section>

                <section>
                    <section>
                        <h1>Retrouver l'info</h1>
                    </section>

                    <section>
                        <h2>Voir les différences entre deux états</h2>
                        <pre><code>
$ git diff  # Montre les différences entre le WD et le staging
$ git diff &lt;file&gt;  # Limite à un seul fichier ou chemin
$ git diff --cached  # Différences entre staging et HEAD
$ git diff HEAD  # Différences entre le WD et HEAD
$ git diff &lt;commit&gt;  # Différences avec un commit / branch particulier
$ git diff &lt;commit&gt; &lt;commit&gt; # Différences entre deux commits
$ git diff --word-diff  # Différences mot à mot (au lieu de ligne à ligne)
$ git diff -w  # Ignore les espaces dans la comparaison
                        </code></pre>
                    </section>

                    <section>
                        <h2>Fouiller l'historique</h2>
                        <pre><code>
$ git log
$ git log &lt;branch&gt;
$ git log --author=Thibault
$ git log --grep=keyword -i -E
$ git log --graph
$ git log --format=oneline
$ git log --since="yesterday"
$ git log --since="1 hour ago"
$ git lg
                        </code></pre>
                    </section>

                    <section>
                        <h2>Voir des objets git</h2>
                        <pre><code>
$ git show  # Voir le dernier commit
$ git show &lt;commit&gt;
$ git show &lt;blob&gt;
$ git show &lt;tag&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un commit / révision</h2>
                        <pre><code>
$ git … HEAD^
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8
$ git … efc95493798d878735a7ecf823c3aaacb59cf8c8^^
$ git … efc95493798d8~3
$ git … hotfixes@{yesterday}
$ git … HEAD@{5}
$ git … HEAD@{"1 hour ago"}
                        </code></pre>
                    </section>

                    <section>
                        <h2>Spécifier un intervalle de commits</h2>
                        <pre><code>
$ git log efc95493798d8..
$ git log efc95493798d8..efc95493798d8~5
$ git log HEAD~5..
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Affichez le log du dépôt tpgit</li>
                            <li>Affichez le détail d'un commit</li>
                            <li>Affichez les modifs des 5 derniers commits</li>
                            <li>Affichez les modifs de cette semaine</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Les branches</h1>
                        <p>Tatatiiiiinnn…</p>
                    </section>

                    <section>
                        <h2>Utilisez-les!</h2>
                        <p>Avec d'autres SCM, les branches sont lentes, complexes et pénibles à utiliser.</p>
                        <p>Pas avec Git ! Les branches sont un outil essentiel à maîtriser.</p>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'une branche ?</h2>
                        <p>Uniquement une étiquette qui pointe sur un commit.</p>
                        <p>C'est tout ? C'est tout !</p>
                    </section>

                    <section>
                        <h2>La branche master</h2>
                        <img src="img/git_imgs/git_branch1.png" alt="" />
                    </section>

                    <section>
                        <h2>La branche master</h2>
                        <img src="img/git_imgs/git_branch2.png" alt="" />
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_create_branch_3.png" />
                        <pre><code>
                            $ git branch test
                            $ git checkout test
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_1.png" />
                        <pre><code>
                            Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_2.png" />
                        <pre><code>
                            $ git checkout master
                        </code></pre>
                    </section>

                    <section>
                        <h2>D'une branche à l'autre</h2>
                        <img src="img/git_imgs/git_work_branch_3.png" />
                        <pre><code>
                            $ Edit… Edit… Edit…
                            $ git commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <p>Créer / supprimer une branche est… rapide !</p>
                        <p>Il est possible de créer une branche n'importe quand… même depuis un ancien commit !</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Oups, j'ai oublié de faire une branche.</p>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git branch new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                         \
                                          new_feature
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git reset --soft HEAD~2
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ Commit… Commit… Commit…
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature
                                 \
                                  E---F---G &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Exemple</h2>
                        <pre><code>
                            $ git checkout new_feature
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; new_feature &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand utiliser une branche ?</h2>
                        <ul>
                            <li>Pour isoler un développement un peu long</li>
                            <li>Pour faire des tests sans casser tout le dépôt</li>
                            <li>Pour mettre quelques commits de côté</li>
                            <li>Juste parce qu'on peut !</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Créer une branche</h2>
                        <pre><code>
                            $ git branch &lt;name&gt; && git checkout &lt;name&gt;
                            $ # ou, plus rapide
                            $ git checkout -b &lt;name&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Passer d'une branche à l'autre</h2>
                        <pre><code>
                            $ git checkout &lt;branch1&gt;
                            $ git checkout &lt;branch2&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer une branche</h2>
                        <pre><code>
                            $ git branch -d &lt;name&gt;
                            $ git branch -D &lt;name&gt;  # si branche non fusionnée
                        </code></pre>
                    </section>

                    <section>
                        <h2>Lister les branches</h2>
                        <pre><code>
                            $ git branch  # Lister les branches locales
                            $ git branch -r  # Lister les branches distantes
                            $ git branch -a  # Combine les deux
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Listez toutes les branches du dépôt</li>
                            <li>Listez les branches non fusionnées</li>
                            <li>Passez de la branch master à la branche dev</li>
                            <li>Visualisez les différences entre les deux</li>
                            <li>Supprimez la branche "test_branch"</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Fusions de branches</h1>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <p>Now… what?</p>
                    </section>

                    <section>
                        <h2>Pas de panique !</h2>
                        <p>Si vous avez déjà tenté une fusion avec SVN ou autre, il est
                           probable que vous soyez terrifié.</p>
                        <p>Avec Git, ça va bien se passer :)</p>
                    </section>

                    <section>
                        <h2>Avant la fusion…</h2>
                        <p>Il est important d'avoir un dépôt propre.</p>
                        <p>Tous les fichiers sont commités, le WD et l'index sont propres.</p>
                        <p>Placer le HEAD sur la branche principale.</p>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            A---B &#x2190; master &#x2190; HEAD
                                 \
                                  C---D---E &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                                             \
                                              hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas simple, le fast forward</h2>
                        <pre><code>
                            $ git branch -d hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E &#x2190; master &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Cas plus complexe</h2>
                        <p>Git rejoue les commits de <i>hotfix</i> sur master.</p>
                        <p>Le résultat est enregistré dans un commit qui a deux parents.</p>
                        <p>S'il n'y a pas de conflits, ce sera un commit vide.</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \         /
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Aah! les conflits…</h2>
                        <p>Il arrive qu'un merge ne puisse être réalisé automatiquement.</p>
                        <p>Ex : Le même fichier modifé différemment dans deux branches distinctes.</p>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Imaginons un fichier A, et ses différentes versions à travers le temps.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment se passe un merge ?</h2>
                        <p>Git considère trois versions du fichier : les deux dernières versions, et
                           le dernier ancêtre commun.</p>
                        <pre><code>
                            A1---A2---A3---A4
                                  \
                                   A5---A6---A6
                        </code></pre>
                        <p>Ici, A2, A4 et A6.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p><i>git status</i> permet de voir les fichiers mergés avec succès, et les autres.</p>
                        <p><i>git log --merge -p</i> montre uniquement les commits qui impactent les fichiers à merger.</p>
                        <p><i>git show [:1,:2,:3]:&lt;file&gt;</i> montre les différentes versions du fichier.</p>
                        <p><i>git diff / git difftool</i> pour voir des différences.</p>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Git modifie les fichiers conflictuels pour inclure des marqueurs de diff.</p>
                        <pre><code>
                            Cette ligne est la même dans les deux branches

                            <<<<<<< HEAD
                            Ajouté dans la branche master
                            =======
                            Ajouté dans la branche test
                            >>>>>>> test

                            Cette partie du fichier est commune
                        </code></pre>
                    </section>

                    <section>
                        <h2>Résoudre les conflits</h2>
                        <p>Modifier le fichier pour résoudre les conflits.</p>
                        <p><i>git add</i> puis <i>git commit</i></p>
                        <p><i>git mergetool</i> permet de lancer un outil de résolution de merge.</p>
                    </section>

                    <section>
                        <h2>Que faire après un merge ?</h2>
                        <pre><code>
                            $ git branch --merged  # montre toutes les branches mergées
                            $ git branch -d &lt;bug_42&gt;  # supprime la branche
                            $ git branch --no-merged  # montre les branches non fusionnées
                        </code></pre>
                        <p>Même une fois fusionnée, une branche peut continuer à vivre. Un autre
                            merge pourra être réalisé plus tard.</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <p>Tentons l'expérience suivante :</p>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git branch -D hotfix
                        </code></pre>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                        </code></pre>
                        <p>Les commits de ma branche <i>hotfix</i> sont-ils perdus ?</p>
                    </section>

                    <section>
                        <h2>Et si je supprime une branche non fusionnée ?</h2>
                        <pre><code>
                            A---B---C---D---H &#x2190; master &#x2190; HEAD
                                 \
                                  E---F---G
                        </code></pre>
                        <p>En fait, les commits existent toujours, ils sont simplement inaccessibles.</p>
                        <p>Au bout de quelques jours, ils seront supprimés par le <i>Garbage collector</i> de git.</p>
                    </section>

                    <section>
                        <h2>Le reflog</h2>
                        <p>Git garde une trace de tous les changements de position de HEAD.</p>
                        <pre><code>
                            $ git reflog
                            $ git checkout G
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; HEAD
                        </code></pre>
                        <p>Mais… HEAD pointe directement vers un commit ? Pas une branche ?</p>
                    </section>

                    <section>
                        <h2>L'état <i>Detached HEAD</i></h2>
                        <p>Quand HEAD pointe directement vers un commit, on parle de detached HEAD.
                           Pour retrouver une situation stable, il suffit de créer une branche,
                           et de continuer comme si de rien n'était.</p>
                        <pre><code>
                            $ git checkout -b newbranch
                        </code></pre>
                        <pre><code>
                            A---B---C---D---H &#x2190; master
                                 \
                                  E---F---G &#x2190; newbranch &#x2190; HEAD
                        </code></pre>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Fusionnez feature1 vers master</li>
                            <li>Supprimez feature2</li>
                            <li>Changez d'avis, et récupérez la branche feature2</li>
                            <li>Fusionnez feature2 vers master</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Rebasing</h1>
                    </section>

                    <section>
                        <h2>Qu'est-ce qu'un rebase ?</h2>
                        <p>Le rebase est une autre façon d'intégrer les modifications de
                            deux branches.</p>
                        <p><i>git rebase</i> réapplique les commits d'une branche sur
                            une autre base.</p>
                    </section>

                    <section>
                        <h2>Merge vs. Rebase</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <pre><code>
                            $ git merge hotfix
                        </code></pre>

                        <pre><code>
                            A---B---C---D---H &#x2190; master, hotfix
                                 \         /
                                  E---F---G
                        </code></pre>
                        <pre><code>
                            $ git rebase master
                        </code></pre>

                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; hotfix
                                         \
                                          master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Comment ça fonctionne ?</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master
                                 \
                                  E---F---G &#x2190; hotfix
                        </code></pre>
                        <ol>
                            <li>git met de côté tous les commits de la branche <i>hotfix</i></li>
                            <li>la branche <i>hotfix</i> est déplacée sur le dernier commit de <i>master</i></li>
                            <li>les commits de côté sont tous ré-appliqués <em>un par un</em></li>
                        </ol>
                    </section>

                    <section>
                        <h2>Conséquences</h2>
                        <ul>
                            <li>Le résultat est le même que le merge, mais l'historique est « plat »</li>
                            <li>Il n'y a pas de commits de fusion vide</li>
                            <li>Chaque commit peut provoquer un conflit</li>
                            <li>Les commits sont réécrits, ce ne sont pas les mêmes (ids différents)</li>
                        </ul>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Quand privilégier rebase sur merge ?</h2>
                        <ul>
                            <li>Soigner son historique</li>
                            <li>Faciliter l'intégration de branches</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <p>Si l'on créé de petites branches en local, on se retrouve facilement
                            avec beaucoup de commits de fusion, et un historique difficile à lire.</p>
                        <pre><code>
                                      F---G &#x2190; bug2
                                     /
                            A---B---E---H---I &#x2190; master
                                 \
                                  C---D &#x2190; bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Éviter les commits de fusion</h2>
                        <pre><code>
                            $ git rebase master bug1
                            $ git checkout master && merge bug1
                            $ git rebase master bug2
                            $ git checkout master && merge bug2
                        </code></pre>
                        <pre><code>
                                                                 bug2
                                                                /
                            A---B---E---H---I---C'---D'---F'---G' &#x2190; master
                                                      \
                                                       bug1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <p>Je n'ai pas créé ma branche depuis le bon commit.</p>
                        <pre><code>
                            A---B---H---I---J &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                                       \
                                        E---F &#x2190; bug_urgent
                        </code></pre>
                        <p>Et si je veux passer <i>bug_urgent</i> en production, mais
                            pas <i>bug_en_cours</i> ?</p>
                    </section>

                    <section>
                        <h2>Réparer un mauvais historique</h2>
                        <pre><code>
                            $ git rebase --onto production bug_en_cours bug_urgent
                        </code></pre>
                        <pre><code>
                            A---B---H---I---J---E'---F' &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_en_cours
                        </code></pre>
                        <p>Les commits sont tous ceux qui sont dans <i>bug_urgent</i>
                            mais pas dans <i>bug_en_cours</i>.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            A---B &#x2190; production
                                 \
                                  C---D---G &#x2190; bug_1
                                       \
                                        E---F &#x2190; bug_2
                        </code></pre>
                        <p>Oups ! bug_1 et bug_2 n'ont rien à voir.</p>
                    </section>

                    <section>
                        <h2>Autre exemple</h2>
                        <pre><code>
                            $ git rebase --onto production  bug_1 bug_2
                        </code></pre>
                        <pre><code>
                            A---B &#x2190; production
                                |\
                                | C---D---G &#x2190; bug_1
                                 \
                                   E'---F' &#x2190; bug_2

                        </code></pre>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <p>Si je veux supprimer les commits C et D ?</p>
                    </section>

                    <section>
                        <h2>Supprimer des commits</h2>
                        <pre><code>
                            A---B---C---D---E---F---G &#x2190; master
                        </code></pre>
                        <pre><code>
                            $ git rebase --onto B D master
                            $ # Remplacer B et D par les sha1 des commits
                        </code></pre>
                        <pre><code>
                            A---B---E'---F'---G' &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                 \
                                  E---F---G &#x2190; master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Travailler proprement avec les branches distantes</h2>
                        <pre><code>
                            $ git pull --rebase
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; master distant
                                         \
                                          E'---F'---G' &#x2190; master local
                        </code></pre>
                        <pre><code>
                            $ git push
                        </code></pre>
                        <pre><code>
                            A---B---C---D---E'---F'---G' &#x2190; master distant
                                                       \
                                                        master local
                        </code></pre>
                    </section>

                    <section>
                        <h2>Grands pouvoirs, grandes responsabilités</h2>
                        <p>si vous réécrivez l'historique d'une branche partagée,
                            vos collègues vous tremperont dans le goudron et les plumes.</p>
                        <p><i>git rebase</i> ne doit donc être utilisé que pour
                            les branches locales.</p>
                    </section>

                    <section>
                        <h2>Et si un rebase ne se passe pas bien ?</h2>
                        <p>Les commits sont réappliqués un par un. Il y a donc des
                            conflits potentiels.</p>
                        <pre><code>
                            $ git status  # Comprendre ce qui se passe
                            $ # régler le conflit, puis :
                            $ git rebase --continue  # reprendre le travail, ou
                            $ git rebase --abort  # Tout annuler, ou
                            $ git rebase --skip  # Continuer en laissant de côté ce commit
                        </code></pre>
                    </section>

                    <section>
                        <h2>Eh ! pssst !</h2>
                        <p>Pour frimer : git rerere</p>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Rebasez feature3 vers master</li>
                            <li>Rebasez hotfix vers master</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Dépôts distants</h1>
                        <p>Parce qu'il faut bien partager le code à un moment ou à un autre.</p>
                    </section>

                    <section>
                        <h2>Git est décentralisé</h2>
                        <p>Rappel : git est un système décentralisé. Il n'y a pas
                            de notion de dépôt central.</p>
                        <p>Sauf par convention.</p>
                        <p>Il est donc possible de créer autant de dépôts distants
                            que nécessaire.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p>Si vous clonez un dépôt, git l'enregistre comme dépôt distant
                            dans le nouveau dépôt local.
                        </p>
                        <pre><code>
                            $ git clone …
                            $ git remote  # Lister les dépôts distants
                            $ git remote show origin  # Détail sur le dépôt distant
                        </code></pre>
                       <p>Par convention, le dépôt distant par défaut se nomme <i>origin</i>.</p>
                    </section>

                    <section>
                        <h2>Git remote</h2>
                        <p><i>git remote</i> sert à gérer les dépôts distants.</p>
                        <pre><code>
                            $ git remote add &lt;name&gt; &lt;url&gt;  # Ajoute un nouveau remote
                            $ git remote rm …
                            $ git remote mv …
                            $ git help remote
                        </code></pre>
                    </section>

                    <section>
                        <h2>Protocoles de communication</h2>
                        <p>Un dépôt git peut être partagé via de nombreux protocoles. Parmi les plus courants :</p>
                        <ul>
                            <li>SSH : ssh://[user@]host.xz[:port]/path/to/repo.git/</li>
                            <li>GIT : git://host.xz[:port]/path/to/repo.git/</li>
                            <li>Filesystem : file:///path/to/repo.git</li>
                        </ul>
                        <p>Ssh:// est le plus sécurisé et recommandé. Git:// est en read-only.
                           Le filesystem n'est à utiliser que pour les tests durant cette
                           formation.</p>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <p>Une branche distante est une branche locale <i>read-only</i>
                            qui représente une branche sur le dépôt distant. Euh… wat ?
                        </p>
                        <pre><code>
                            $ git branch -a
                            * master
                            remotes/origin/master
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches distantes</h2>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                         \
                                          master
                        </code></pre>
                        <pre><code>
                            A---B---C---D &#x2190; origin/master
                                     \
                                      master
                        </code></pre>
                        <pre><code>
                            A---B---C &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                        <pre><code>
                            A---B---C---E &#x2190; origin/master
                                     \
                                      D &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D &#x2190; origin/master
                                         \
                                          E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Mettre à jour le dépôt local</h2>
                        <pre><code>
                            $ git fetch  # Télécharge les données du serveur
                            $ git merge / git rebase  # ou, plus court :
                            $ git pull / git pull --rebase
                        </code></pre>
                        <pre><code>
                            Serveur distant :

                            A---B---C---D---G &#x2190; master

                            Serveur local :

                            A---B---C---D---G &#x2190; origin/master
                                             \
                                              E---F &#x2190; master
                        </code></pre>
                    </section>

                    <section>
                        <h2>Branches trackées ou non</h2>
                        <p>Toutes les branches locales n'ont pas à être sur le serveur, et
                            vice-versa.</p>
                        <p>Une <i>branche trackée</i> est une branche locale qui a
                            une relation directe avec une branche distante.</p>
                        <pre><code>
            $ git fetch  # Ne télécharge que les branches trackées de origin
            $ git fetch origin &lt;branch&gt;  # Pour les autres branches
            $ git pull  # Fetch + pull pour les branches correspondantes
            $ git push  # Envoie les données vers la branches distante correspondante
            $ git checkout -b origin/&lt;branch&gt;  # Récupère et tracke une branche distante
                        </code></pre>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p><i>git push</i> envoie les données locales sur le serveur distant.</p>
                        <pre><code>
                            $ git push  # Seulement les branches trackées
                            $ git push -u origin &lt;branch&gt; # Push une nouvelle branche
                            $ git push origin :&lt;branch&gt;  # Supprime une branche distante
                        </code></pre>
                    </section>

                    <section>
                        <h2>Envoyer son travail sur le serveur</h2>
                        <p>Évidemment, il faut avoir un droit le lecture / écriture sur le dépôt distant.</p>
                        <p>Il faut également que le dépôt local soit à jour.</p>
                    </section>

                    <section>
                        <h2>TP</h2>
                        <ul>
                            <li>Affichez la liste des branches distantes</li>
                            <li>Affichez le log de la branche master distante</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Organisation et workflows</h1>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Avec git, on peut créer autant qu'on veut de :</p>
                        <ul>
                            <li>branches locales ;</li>
                            <li>dépôts distants ;</li>
                            <li>branches distantes.</li>
                        </ul>
                        <p>Sans obligations de correspondances directes entre les uns et les autres.</p>
                    </section>

                    <section>
                        <h2>Bienvenue dans la jungle</h2>
                        <p>Du coup, ça peut vite devenir… b**lique.</p>
                        <ol>
                            <li>Comment organiser ses branches locales ?</li>
                            <li>Quel workflow pour le travail collaboratif ?</li>
                        </ol>
                        <p>Il n'y a pas de réponses unique, mais voici quelques pistes de réflexion.</p>
                    </section>

                    <section>
                        <h2>Organiser ses branches</h2>
                        <p>Journée classique d'un développeur :</p>
                        <ul>
                            <li>Je travaille sur un projet X</li>
                            <li>Depuis une semaine, je bosse sur la fonctionnalité Y, assez complexe</li>
                            <li>En parallèle, je dois résoudre un bug complexe avant la fin de la semaine</li>
                            <li>Zut ! le client remonte un bug, simple à corriger mais urgent</li>
                        </ul>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Exemples de mauvaises pratiques issues d'une habitude SVN :</p>
                        <ol>
                            <li>Travailler sur une seule branche (master) ;</li>
                            <li>Pusher trés régulièrement ;</li>
                            <li>Puller trés régulièrement ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>SVN (bad) style</h2>
                        <p>Conséquences :</p>
                        <ol>
                            <li>La branche principale est potentiellement cassée ;</li>
                            <li>L'historique global est pourri de commits de fusion ;</li>
                            <li>Mes développements sont mélangés dans mon historique ;</li>
                        </ol>
                    </section>

                    <section>
                        <h2>Propositions de workflows</h2>
                        <p>Deux branches permanentes.</p>
                        <p><i>Master</i> contient le code déployé en production.</p>
                        <p><i>Dev</i> est la branche d'intégration.</p>
                        <pre><code>
                                        v1.0.0  v1.0.1
                                       /       /
                            o---------o-------o &#x2190; master
                                     /       /
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <p><i>Master</i> est <em>toujours</em> stable, et peut donc
                            servir pour déployer régulièrement (déploiement automatique).</p>
                        <p><i>Dev</i> contient tous les derniers développements, et
                            sert pour l'intégration continue (tests + builds).</p>
                    </section>

                    <section>
                        <h2>Développer des fonctionnalités</h2>
                        <pre><code>
                              o---o---o---o---o &#x2190; feature-login
                             /                 \
                            o---o-----------o---o---o  &#x2190; dev
                            |    \         /
                            |     o---o---o &#x2190; feature-newsletter
                             \
                              o---o---o---o &#x2190; feature-stupidtest
                        </code></pre>
                        <pre><code>
                            $ git checkout -b feature-login dev
                            $ Commit… Commit… Commit…
                            $ git checkout dev
                            $ git merge --no-ff feature-login
                            $ git branch -d feature-login
                        </code></pre>
                    </section>

                    <section>
                        <h2>Préparer une <i>release</i></h2>
                        <pre><code>
                                                  v1.0.1
                                                 /
                            o---------o---------o &#x2190; master
                                               /
                                      o---o---o &#x2190; release-1.0.1
                                     /     \   \
                            o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b release-1.0.1 dev
                            $ cat "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff release-1.0.1
                            $ git tag -a 1.0.1
                            $ git checkout dev
                            $ git merge --no-ff release-1.0.1
                            $ git branch -d release-1.0.1
                        </code></pre>
                    </section>

                    <section>
                        <h2>Corriger un bug urgent</h2>
                        <pre><code>
                                                    v1.0.2
                                                   /
                            o---------o-----------o &#x2190; master
                                       \         /
                                        o---o---o &#x2190; hotfix-1.0.2
                                                 \
                              o---o---o---o---o---o  &#x2190; dev
                        </code></pre>
                        <pre><code>
                            $ git checkout -b hotfix-1.0.2 master
                            $ cat "1.0.1" > VERSION
                            $ git commit -am "Bump version number"
                            $ Corrige un bug… Commit…
                            $ git checkout master
                            $ git merge --no-ff hotfix-1.0.2
                            $ git tag -a 1.0.2
                            $ git checkout dev
                            $ git merge --no-ff hotfix-1.0.2
                            $ git branch -d hotfix-1.0.2
                        </code></pre>
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt centralisé</h3>
                        <p>Le plus simple pour démarrer.</p>
                        <img src="img/workflow1.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le dépôt d'intégration</h3>
                        <img src="img/workflow2.png" />
                    </section>

                    <section>
                        <h2>Organiser ses dépôts distants</h2>
                        <h3>Le modèle « dictateur / lieutenants »</h3>
                        <p>Pour les trés gros projets.</p>
                        <img src="img/workflow3.png" />
                    </section>
                </section>
            </div>

        </div>

        <script src="../reveal.js/lib/js/head.min.js"></script>
        <script src="../reveal.js/js/reveal.min.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                rollingLinks: false,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });
        </script>
    </body>
</html>
